### Java核心技术

#### 第三章 Java的基本程序设计结构

##### 3.1 一个简单的Java应用程序

```java
public class FirstSample {
    public static void main(String[] args) {
        System.out.println("Hello World!");
    }
}
```

Java应用程序都具有上述这种结构，首先Java区分大小写，如果拼写错误程序将无法执行。关键字public被称为访问修饰符，用于控制其他部分，对该部分的访问权限。class表明Java程序的所有内容都必须放在类中。关键字class后必须紧跟类名，类命必须以字母(此处的字母指英文字母，和少量字符，如下划线等)开头，后面可以跟字母、数字、下划线等少数字符的任意组合，长度上基本没有限制，但不能使用Java中的保留字。类命命名规范：每个字母单词大写。

##### 3.2 注释

单行注释 //

多行注释 /*   */

文档注释 /**    */

##### 3.3 数据类型

###### 3.3.1 整型

Java提供了四种整型（Java中没有无符号的byte、short、int、long类型）

* byte     		   1字节
* short		      2字节 
* int                   4字节
* long                8字节               

###### 3.3.2 浮点型

Java中有两种浮点型

* float            4字节

* double        8字节

double类型的数值精度是float的两倍（有人称之为双精度数值）大部分情况下，float的精度很难满足需求。float类型的数值有一个后缀F（f）,没有该后缀默认为double类型。

###### 3.3.3 char类型

char类型用来表示单个字符，需要使用单引号括起来

###### 3.3.4 Unicode和char类型

Java存储字符型的方法，先介绍一些基本概念   

码点：是指一个编码表中某个字符对应的代码值。在Unicode中码点用十六进制编写。

代码单元：UTF-16采用不同长度的编码表示Unicode码点，每个字符用16位表示，通常被称为代码单元，一些辅助字符需要连续两个代码单元进行编码。

###### 3.3.4 boolean类型

布尔类型有两个值true和false,整型和boolean之间不能相互转换。

##### 3.4 变量

在Java中每个变量都有一个类型，声明时，类型要位于变量名之前。如：

```java
int age;
boolean flag;
double salary;
```

变量名必须以字母开头，由字母、数字、下划线等组成。变量名不能使用Java中的保留字。

###### 3.4.1 变量初始化

声明一个变量后，必须显示的进行初始化，使用未初始化的变量编译器将会报错。如：

```java
double salary;
System.out.println(salary);
```

对变量进行初始化，需要将变量名放在=左侧，值放在右侧。Java中变量可以先声明再初始化，也可以在声明的时候初始化。

```java
int age = 18;
double salary;
salary = 99.811;
```

###### 3.4.2 常量

在Java中使用final声明常量，被关键字final修饰的量只能被初始化一次，一旦赋值后，就不能更改。一般常量名使用全大写。

```java
public final double PI = 3.14;
```

##### 3.5 运算符

在Java中使用+ - * / 表示加减乘除操作，当/操作的两个数都是整数时，表示整型运算，否则表示浮点数运算。整数除0会产生一个异常，浮点数除0将会返回无穷大或者NaN。

在最初的虚拟机规范中，为了实现跨平台性，浮点数在进行计算时，必须进行截断，如`double w = x * y / z`有些处理器会使用扩展的80位的寄存器存储中间结果，最后再进行截断，这可能与只有64位的处理器上运行结果不同。但是截断操作遭到了反对，因为不仅结果不准确，截断操作还会消耗一定的时间，因此Java中默认使用扩展的精度，而使用strictfp修饰的类或方法在进行浮点数运算时，必须使用严格的精度。

###### 3.5.1 数学函数与常量

在JDK的Math类中包含了各种数学函数，还有常用的数学常量。

* Math.sin()
* Math.cos()
* Math.tan()
* Math.sqrt()
* Math.pow()
* Math.PI
* Math.E
* ......

###### 3.5.2 数值类型之间的转换

我们经常需要将一种数据类型的数据转换为另一种数据类型，有六种无精度损失的转换，和三种有精度损失的转换。

* byte -> short 	无精度损失
* short-> int         无精度损失
* int->long            无精度损失
* int->double       无精度损失
* char->int           无精度损失
* float->double   无精度损失
* int -> float         有精度损失
* long->float        有精度损失
* long->double    有精度损失

当两数进行二元操作时，需要将两数转换为同一种类型在进行计算。转换规则如下：

* 如果有一个为double类型，则另一个转换为double类型。
* 否则，如果有一个为float类型，则另一个转换为float类型。
* 否则，如果有一个为long类型，则另一个转换为long类型。
* 否则两数都被转换为int类型。

###### 3.5.3 强制类型转换

在必要的时候，上述类型转换会自动地发生，另一方面，有时候也需要进行强制类型转换，这有可能丢失一些信息，强制类型转换的语法是，在圆括号中给出所需要转换的类型，后面紧跟要转换的变量名。

```java
double x = 2.99;
int y = (int)x;
```

###### 3.5.4 结合赋值和运算符

可以在赋值中使用二元运算符。`x+=4`等价于 `x=x+4` ,一般的要把运算符放在=左侧。

###### 3.5.5 自增和自减运算符

自增自减运算符有前缀和后缀两种形式，如`a++`和 `++a`两着都会使值增加1，但前缀是先加1，再运算，后缀则恰恰相反。

###### 3.3.5 关系和boolean运算符

Java中有很多的关系运算符

* = 相等性
* ！= 不等性
* <小于 >大于
* <=小于等于 >=大于等于
* &&逻辑与 ||逻辑或  ！逻辑非  &&和||为短路运算，左边运算可以确定结果时，不进行右边的运算
* a < b ? a : b 三元运算符 

###### 3.5.7 位运算符

* & 与操作符 两数二进制的同一位都为1时，结果为1，否则为0
* | 或操作符  两数二进制的同一位只要有一个为1时，结果为1，否则为0
* ~ 非运算符 如果位为1，结果为0，如果为1，结果为0
* ^ 异或运算  两操作数的同一位相同则结果为1，否则为0
* << 有符号左移操作，操作数的二进制数，除符号位向左移动，高位移除，低位补0
* .>>有符号右移操作，操作数的二进制数，除符号位向右移动，低位移除，正数高位补0，负数高位补1
* .>>>无符号右移，操作数的二进制数，除符号位向右移动，低位移除，无论正负高位补1

###### 3.5.8 括号与运算级别

Java中的运算符级别如下:

* [] . ()
* ! ~ ++ -- +(一元运算) -(一元运算) () (强制类型转换) new
* *、/、 %
* +、-
* <<、 >>、 >>>
* < 、<=、 >、 >=、 instanceof
* ==、!=
* &
* ^
* |
* &&
* ||
* ?:
* = 、+=、-+ 、*= 、/= 、%= 、&= 、|= 、^= 、<<=、 >>=、 >>>= 

###### 3.5.9 枚举类型

有时候变量的取值在一个有限的集合中，如衣服的尺码可以有S、M、L、X，则可以自定义枚举类型。

```JAVA
public enum Size {
    SMALL,
    MEDIUM,
    LEARGE,
    EXTRA_LARGE
}
```

此时我们可以声明枚举类型的变量 `Size s = Size.SMALL;` 变量s只能存储枚举中给定的某个值，或者null(表示尚未给该变量赋值)

##### 3.6 字符串

Java中的字符串就是一个Unicode的字符序列，Java为字符串预定一个类String，每个由双引号引起来的字符串都是String类的一个实例。

###### 3.6.1 子串

String类的substring()方法可以从大的字符串中提取出一个子串。

```java
String s1 = "hello";
String s2 = s1.substring(0,3); // hel  左闭右开
```

###### 3.6.2 拼接

Java中允许使用+将两个字符串进行拼接，当一个字符串和非字符串进行拼接时，后者将被转换成一个字符串。

```java
String s1 = "hello";
String s2 = "world";
String s3 = s1 + s2; // helloworld
int i = 18;
String s4 = s3 + i; // helloworld18
```

如果需要将多个字符串根据给定的分隔符分隔，则可以使用String的join()方法

```java
String s1 = "hello";
String s2 = "world";
String s3 = String.join("-",s1,s2); //hello-world
```

###### 3.6.3 不可变字符串

Java中的字符串是不可变的，String类没有提供用于修改字符串的方法，当需要修改字符串内容时，可以将当前变量指向一个新的String类的实例。

###### 3.6.4 检测字符串是否相等

可以使用equals()方法判断两个字符串是否相等，在调用方法时，可以使用字符串变量，也可以使用字面量，如果要忽略大小写进行比较，则可以使用equalgnoreCase()方法。

```java
boolean flag1 = s1.equals(s2); // false
boolean flag2 = "hello".equals("hello"); //true
boolean flag3 = s1.equalsIgnoreCase("HELLO"); //true
```

使用==判断的是两个字符串是否指向了内存中的同一个String类的实例，若虚拟机始终将相同内容的字符串共享，则也可以使用==来判断，但是+、substring()等操作产生的字符串是不共享的。

###### 3.6.5 空串与null串

空串“”是长度为0的字符串，可以使用以下代码来判断。

```java
if (str.length() == 0)或if (str.equals(""))
```

空串表示字符串的长度为0，内容为空，null串是指该变量尚未与任何String类的实例相关联。可以使用以下代码来判断

```java
if (str == null)
```

有时候既需要判断字符串不为null，内容也不为空，则可以做以下判断。

```java
if (str != null && str.length() > 0)
```

###### 3.6.6 码点与代码单元

Java字符串是一个char值序列，而char值是由UTF-16编码Unicode码点的代码单元，大多数字符需要一个代码单元来表示，而一些辅助字符则需要一对代码单元组成。

使用length()方法将返回字符串的代码单元数量：

```java
String s1 = "hello";
int i = s1.length(); // 5
```

想要得到码点数量，则需要调用codePointCount()方法。

```java
String s1 = "hello";
int codePointCount = s1.codePointCount(0,s1.length()); // 5
```

调用charAt(i)将返回位置i上的代码单元

```java
String s1 = "hello";
char first = s1.charAt(0); // h
char end = s1.charAt(4); //o
```

想要得到第i个位置的码点，则需要进行以下调用。

```java
String s1 = "hello";
int index = s1.offsetByCodePoints(0,i);
int cp = s1.codePointAt(index);
```

可以调用codePoints()方法得到字符串的码点的“流”，可以将之转换为数组。

```java
String s1 = "hello";
int[] codes = s1.codePoints().toArray();
```

也可以根据给定的码点数组构建字符串。

```java
String s1 = "hello";
int[] codes = s1.codePoints().toArray();
String str = new String(codes,0,codes.length);
```

###### 3.6.7 String API

Java中的String类提供了很多方法，以下列出一些常用的方法。

* char charAt(int index)返回给定位置的代码单元
* int codePointAt(int index)返回给定位置的码点
* int offsetByCodePoints(int startIndex,int cpCount)返回从startIndex开始，位移cpCount后的码点索引。
* int compareTo(String other) 按照字典顺序，若字符串位于other之前，返回负数，若位于other之后，返回正数，若两字符串相等，返回0
* IntStream codePoints()返回字符串的码点流
* new String(int[] codePoints,int offset,int count) 由码点数组offset位置开始，数量为count的码点构建字符串。
* boolean equals(String other)判断两字符串是否相等
* boolean equalsIgnoreCase(String other)忽略大小写判断两字符串是否相等
* boolean startWith(String prefix)判断字符串是否以prefix开头
* boolean endWith(String suffix)判断字符串是否以suffix结尾
* int indexOf(String str)返回字符串str在该串中第一次出现的索引，从0开始
* int indexOf(String str，int fromIndex)返回字符串str在该串中第一次出现的索引，从fromIndex开始
* int indexOf(int cp)返回码点cp在该串中第一次出现的索引，从0开始
* int indexOf(int cp，int fromIndex)返回码点cp在该串中第一次出现的索引，从fromIndex开始
* int lastIndexOf(String str)返回字符串str在该串中最后一次出现的索引，从串尾开始
* int lastIndexOf(String str，int fromIndex)返回字符串str在该串中最后一次出现的索引，从fromIndex开始
* int lastIndexOf(int cp)返回码点cp在该串中最后一次出现的索引，从串尾开始
* int lastIndexOf(int cp，int fromIndex)返回码点cp在该串中最后一次出现的索引，从fromIndex开始
* int length()返回字符串长度
* int codePointCount(int startIndex,int endIndex)返回指定区间的码点数量
* String replace(CharSequence oldString,CharSequence newString)使用newString替换掉原串中的oldString之后返回一个新串。
* String subString(int startIndex)从startIndex到串尾截取后返回新串。
* String subString(int startIndex,int endIndex)从startIndex到endIndex截取后返回新串。
* String toLowerCase()将原串转换为小写返回新串
* String toUpperCase()将原串转换为大写返回新串
* String trim()去除原串首尾的空格后返回新串
* String join(CharSequence delimiter,CharSequence ...elements)将字符串根据给定的分隔符连接，返回新串。

###### 3.6.8 阅读联机API文档

JDK8在线API文档地址：https://docs.oracle.com/javase/8/docs/api/

###### 3.6.9 构建字符串

如果需要构建字符串，如果使用拼接的形式，在构造过程中会构造一些新的字符串，而且效率低下，可以使用StringBuffer或StringBulider类来进行构造。当需要追加一部分内容时，可以调用append()方法，构建完成时，调用toString()方法返回该字符串。

```java
StringBuffer sb = new StringBuffer();
sb.append(6);
sb.append('c');
sb.append("def");
String s = sb.toString(); //6cdef
```

StringBuilder类和StringBuffer的相同点和不同点：

相同点：

* 初始容量16
* 扩容机制 2*n+2

不同点：

* StringBuffer线程安全，StringBulider线程不安全
* StringBuffer有字符缓冲区，StringBulider没有

##### 3.7 输入输出

###### 3.7.1 读取输入

在Java中读取输入时，可以使用Scanner类，使用new创建一个Scanner类的实例，并与一个标准输入流相关联，就可以读取输入了。

```java
Scanner sc = new Scanner(System.in); //读取控制台输入
System.out.println("Whis's your name?");
String name = sc.nextLine();
```

使用Scanner类读取输入时，内容是可见的，因此不适合用来读取密码，此时应该使用Console类。

```java
Console cons = System.console();
String username = cons.readLine("username:");
char[] password = cons.readPassword("password:");
```

###### 3.7.2 格式化输出

在Java中延续了C语言的printf方法，用于对输出进行格式化。

```java
System.out.printf("Hello %s next year you will be %d",name,age);
```

每一个以%开始的格式，都代表了相应数据类型的参数替换，如,%s对应字符串，%d代替十进制整数等。以下是参数替换的参数。

* d 十进制整数
* x 十六进制整数
* o 八进制整数
* f 定点浮点数
* e 指数浮点数
* g 通用浮点数
* a 十六进制浮点数
* s 字符串
* c 字符
* b 布尔值
* h 散列码
* tx或Tx 日期时间
* % 百分号
* n 行分隔符

还有一些用于控制格式化输出的各种标志，如分组分隔符 逗号

```java
System.out.printf("%,d",99999999); //99,999,999
```

以下是所有的分组分隔符。

* 加号+ 用于打印正负数的符号
* 空格   在正数之前补空格
* 0 数字前补0
* 横线 - 左对齐
* ( 将负数括起来
* 逗号， 分组分隔符
* #对于f格式包含小数点 对于x或0格式，添加前缀0x或0
* $ 给定格式化参数类型的索引 索引从1开始
* < 格式化前面说明的数值 %d%<x 将以十进制和十六进制打印同一个数字

可以使用%s格式化任何对象，当该对象实现了Formattable接口时，将调用formatTo方法，否则调用toString方法。

```java
public static void main(String[] args) {
    User user = new User("hyy",18);
    System.out.printf("%s",user);
}

private static class User implements Formattable {
   private String name;
   private Integer age;

    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }

    @Override
    public void formatTo(Formatter formatter, int flags, int width, int precision){
        try {
            Appendable out = formatter.out();
            out.append("My name is ").append(this.name)
                    .append(", and i am ").append(this.age.toString()).append(" years old");
        }catch (IOException e){
        }
    }
}
```

可以使用String类的静态方法format()方法格式化字符串而不进行输出。

```java
String name = "hyy";
String fmtStr = String.format("My name is %s",name);
```

Java中还有格式化日期的参数，但已经有更好的方法格式化时间。此处了解

###### 3.7.3 文件输入输出

如果需要对文件进行读取，就需要通过文件构造一个Scanner对象

```java
Scanner sc = new Scanner(Paths.get("D:\\file.txt"),"utf-8");
```

想要写入方法时，可以构造PrintWriter对象，如果文件不存在，则会创建新文件。可以调用pringf()、println()、print()方法写入数据。

```java
PrintWriter pw = new PrintWriter("D:\\file.txt","utf-8");
```

##### 3.8 流程控制

###### 3.8.1 块作用域

块是由一对大括号括起来的区域，块确定了一个变量的作用域。块可以进行嵌套，不能在嵌套的块中声明同名的变量。

```java
public static void main(String[] args) throws IOException {

    {
        int n;
        {
            int n; //Error
        }
    }

}
```

###### 3.8.2 条件语句 

Java中的条件判断语句是使用if...else...if完成的，if语句可以单独出现，else和 else if只能出现在if或else if之后。

```java
int a = 100;
if (a < 0){
    
}else if (a == 0){
    
}else {
    
}
```

###### 3.8.3 循环

Java中的循环语句由wile和do...while两种，while会先判断条件，再执行循环体，因此有可能一次也不执行，而do...while先执行一次循环体，再判断条件，依次类推。

```java
int a = 100;
while (a > 0){
    a--;
}

do {
    a--;
}
while (a>0);
```

###### 3.8.4 确定循环

Java中还有for语句来进行循环。

```java
int a = 100;
for (int i = 0; i < 100; i++) {
    System.out.println(i);
}
```

###### 3.8.5 多重选择switch语句

当if...else语句较为复杂时，显得非常笨重，此时可以使用switch语句。

```java
String str = "A";
switch (str){
    case "A":
        System.out.println("A");
        break;
    case "a":
        System.out.println("a");
        break;
}
```

支持switch语句的变量有，char、byte、short、int、long及其包装类，枚举常量以及字符串。

###### 3.8.6 中断流程控制语句

Java中的流程控制语句由break和continue两种，break会中断循环，继续执行程序的其余部分，continue将跳过当前循环的剩余部分，跳到循环头，开始下一次循环。break和continue还可以使用带标签的形式，跳到指定循环的部分。

```java
a:
while (a){
    b:
    while (b){
        continue a;
        while (c){
            break b;
        }
        
    }
}
```

##### 3.9 大数值

当基本的整型和浮点型无法满足需求时，可以使用Java提供的两个类：BigInteger和BigDecimal类操作整型和浮点型。可以使用valueOf()方法将基本数据类型转换为大数值。

```java
BigInteger i = BigInteger.valueOf(123);
```

大数值不能进行+-*/语法进行运算，而是调用内置的方法进行运算，以下是两个类的常用方法。

BigInteger类：

* add(BigInteger other) 加法
* subtract(BigInteger other) 减法
* multiply(BigInteger other) 乘法
* divide(BigInteger other) 除法
* mod(BigInteger other) 取余
* compareTo(BigInteger other) 比较
* static valueOf(int value) 基本数据类型转换为大数值

BigDecimal类：

* add(BigDecimalother) 加法
* subtract(BigDecimalother) 减法
* multiply(BigDecimalother) 乘法
* divide(BigDecimalother) 除法
* compareTo(BigDecimalother) 比较
* static valueOf(long x) 基本数据类型转换为大数值
* static valueOf(long x,int sacle) 指定精度返回大数值

##### 3.10 数组

数组是一种数据结构，用来存储一组相同数据类型的数据，可以通过索引进行访问，数组的语法为：

```java
int n = 100;
int[] arr = new int[100];
int[] brr = new int[n];
```

可以访问数组的length属性获取数组长度，数组一旦创建，其长度就不再发生变化。

```java
int length = arr.length
```

###### 3.10.1 for each循环

Java中可以使用for each循环遍历数组（或其他集合）,for each语法如下：

```java
int[] arr = new int[100];
for (int i : arr) {
    System.out.println(i);
}
```

###### 3.10.2 数组的初始化和匿名数组

Java提供了一种可以创建并初始化数组的语法，数组的长度就是初始化值的长度，形式如下：

```java
int[] arr = {1,2,3,4,5};
```

还可以创建一个匿名数组：

```java
new int[]{5,4,3,2,1};
```

使用匿名数组语法，可以在不创建新变量的情况下，对变量赋新值。

```java
arr = new int[]{5,4,3,2,1};
```

###### 3.10.3 数组拷贝

Java中有两种数组拷贝的方式，第一是将一个数组变量拷贝给一个新的变量，此时两个变量将指向同一个引用。

```java
int[] arr = new int[10];
int[] brr = arr;
```

另一种是调用Arrays.copyOf()方法将一个数组中的值，拷贝到另一个新数组中。

```java
int[] arr = new int[10];
for (int i = 0; i < 10; i++) {
    arr[i] = i;
}
int[] ints = Arrays.copyOf(arr, 20);//第二个参数是新数组长度
```

如果第二个参数大于原数组长度，多余部分会被赋初值，如果小于原数组长度，则只拷贝数组的前一部分。

###### 3.10.4 命令行参数

Java中的main方法有字符串数组类型的参数，因此我们可以使用带参数的命令启动Java程序，这些参数将被封装到main方法的参数中。

```java
public class Main {
    public static void main(String[] args) {
        for (String str : args) {
            System.out.println(str);
        }
    }
}
```

可以在控制台输入以下命令将参数封装到main方法中。

```java
java Main hello world //参数从hello开始算,Main为类名n
```

###### 3.10.5 数组排序

可以使用Arrays.sort()方法对数组进行排序，这个方法使用了优化的快速排序算法。Arrays类为我们提供了很多操作数组的简便方法。

* toString(type[] a) 将数组转换为字符串，数组中的元素放在[]中，由逗号隔开。
* coyeOf(type[] a,int length)将数组中的数据拷贝到另一个数组中去，length为新数组长度，也叫拷贝长度。
* copyOfRange(type[] a,int start,int end)将数组中索引从start到end(左闭右开)的区间进行拷贝
* sort(type[] a) 优化的快速排序算法
* binarySearch(type[] a,type v)二分查找
* binarySearch(type[] a,int start,int end,type v)指定范围二分查找
* fill(type[] a,type v) 用 v值填充数组所有位置
* equals(type[] a,types[] b)比较两数组，每个下标对应的值相等时，返回true

###### 3.10.6 多维数组

多维数组可以使用多个索引访问数组中的元素，下面将以二维数组(也称矩阵)作为示例。

```java
int m = 3,n=3;
int[][] arr = new int[m][n];
```

如果事先知道数组中的元素，也可以使用简写的方式对数组中的元素直接进行初始化。

```java
int[][] arr = {
        {1,2,3},
        {4,5,6},
        {7,8,9}
};
```

多维数组在使用for循环或for...each进行遍历时，需要多层循环。

```java
int[][] arr = {
        {1,2,3},
        {4,5,6},
        {7,8,9}
};
for (int[] ints : arr) {
    for (int a : ints) {
        System.out.println(a);
    }
}
```

###### 3.10.7 不规则数组

Java中的实际上没有多维数组，只有一维数组，多维数组其实是数组的数组。因此我们可以构造一个不规则数组。以下代码将构造一个直角三角形形状的数组。

```java
int[][] arr = new int[5][];
 for (int i = 0; i < arr.length; i++) {
     arr[i] = new int[i+1];
 }
```

#### 第四章 对象与类

##### 4.1 面向对象程序设计概述

面向过程解决问题的思路主要是分析问题所需的步骤，再依次根据这些步骤编写方法，再确定方法所需的数据结构面向对象则将对象放在第一位，首先考虑系统中的数据结构，也就是对象，然后再考虑操作数据的方法。

###### 4.1.1 类

类是创建对象的模板，由类构造对象的过程，称为创建类的实例。

封装是指对对象的使用者隐藏了数据的实现方式，对象中的数据称之为实例域，操作数据的过程称之为方法，每个对象都有一组实例域值，这些值的集合就是对象的当前状态。

实现封装的关键在于不能让类中的方法直接操作其他类的实例域，仅通过对象的方法对数据进行操作。

###### 4.1.2 对象

对象的三个特征：

* 对象的行为：应该为对象提供哪些方法？
* 对象的状态：对象的方法，会使对象的状态发生怎样的改变？
* 对象的标识：同一个类的实例如何进行区分？

###### 4.1.3 识别类

###### 4.1.4 类之间的关系

在类之间，最常见的关系有：

* 依赖 uses-a 在一个类中使用到了另一个类
* 聚合 has-a  在一个类中包含了另一个类
* 继承 is-a 一个类继承了另一个类

##### 4.2 使用预定义类

###### 4.2.1 对象与对象变量

使用对象前，必须先创建对象，并指定其初始化状态，在Java中使用构造器创建对象，构造器是一种特殊的方法，构造方法。构造方法的名称必须和类名相同，且没有返回值。创建对象时使用new关键字。

```java
public class User {
    private String name;
    private int age;
    public User(String name, int age) {
        this.name = name;
        this.age = age;
    }
}
User user = new User("hyy",18);
```

在对象和对象变量之间存在一些区别，对象变量只是一个变量，它可以引用一个对象，但本身不是对象。实质上new操作符返回的也是一个引用。

###### 4.2.2 Java类库中的LocalDate类

LocalDate类和Date类都是用来描述时间的，但是Date类的时间是距纪元-UTC时间1970年1月1日00:00:00的毫秒数，而LocalDate类则是一个日历类，可以根据给定的年月日构造时间对象。我们可以使用工厂方法来构造LocalDate类的实例。

```java
LocalDate now = LocalDate.now(); //当前时间
LocalDate localDate = LocalDate.of(2020, 9, 2); //指定年月日
```

可以通过LocalDate对象的getYear()、getMonthValue()、getDayOfMonth()方法获取年月日。也可以使用plusDays()方法，的到距当前对象一定天数的新对象。以下是LocalDate类的常用方法。

* static LocalDate now() 获取当前时间的LocalDate对象 
* static LocalDate of(int year,int month,int day) 获取指定年月日的LocalDate对象 
* int getYear() 获取年
* int getMonthValue() 获取月
* int getDayOfMonth() 获取日
* int getDayOfWeek() 获取周几
* LocalDate plusDays(int n) 生成日期n天后的LocalDate对象
* LocalDate plusDays(int n) 生成日期n天前的LocalDate对象

###### 4.2.3 更改器方法和访问器方法

访问器方法：调用方法不改变自身状态的方法。

更改器方法：调用方法改变了调用者的状态。

##### 4.3 用户自定义类

除了使用Java预定义的内置类，我们还可以在系统中创建一些自己需要的类。以下以Employee类做实例。

###### 4.3.1 Employee类

```java
public class EmployeeTest {
    
    public static void main(String[] args) {
        Employee[] staff = new Employee[3];
        staff[0] = new Employee("hyy",10,LocalDate.now());
        staff[1] = new Employee("hy",100,LocalDate.now());
        staff[2] = new Employee("h",100,LocalDate.now());
        for (Employee employee : staff) {
            employee.raiseSalary(5);
            System.out.println(employee);
        }
    }
}
class Employee{
    private String name;
    private double salary;
    private LocalDate hireDay;

    public Employee() {
    }

    public Employee(String name, double salary, LocalDate hireDay) {
        this.name = name;
        this.salary = salary;
        this.hireDay = hireDay;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public double getSalary() {
        return salary;
    }

    public void setSalary(double salary) {
        this.salary = salary;
    }

    public LocalDate getHireDay() {
        return hireDay;
    }

    public void setHireDay(LocalDate hireDay) {
        this.hireDay = hireDay;
    }

    @Override
    public String toString() {
        return "Employee{" +
                "name='" + name + '\'' +
                ", salary=" + salary +
                ", hireDay=" + hireDay +
                '}';
    }

    public void raiseSalary(double percent){
        double raise = salary * percent /100;
        salary += raise;
    }
}
```

###### 4.3.2 多个源文件的使用

以上的代码将两个类放在了一个文件中，也可以将EmployeeTest类和Employee类放在不同的源文件中。

###### 4.3.3 解析Employee类

首先，看Employee类有哪些实例域：

```java
private String name;
private double salary;
private LocalDate hireDay;
```

这些实例域都是私有的，如果将他们设置为public，则破环了面向对象的封装性。

其次，要分析Employee类的方法：

```java
public Employee()
public Employee(String name, double salary, LocalDate hireDay)
public String getName()
...
public void raiseSalary(double percent)
```

Employee有两个构造方法，和8个普通方法，这些方法都是public的，这意味着，任何类都能调用它们。

###### 4.3.4 从构造方法开始

构造方法与类名相同，它在创建对象时被调用，用来初始化对象的状态，因此总是伴随着new关键字被调用，而不能通过对象调用。

```java
employee.Employee("hyy",10,LocalDate.now());//Error
```

构造器有以下特点：

* 构造器与类名相同
* 一个类可以有多个构造参数
* 构造器可以有0个或若干个参数
* 构造器没有返回值
* 构造器总是伴随着new关键字调用

###### 4.3.5 隐式参数和显式参数

在Java中一般在调用方法时会使用以下语句：

```java
public void raiseSalary(double percent){
	double raise = salary * percent /100;
	salary += raise;
}
employee.raiseSalary(5);
```

该方法有两个参数，第一个是调用该方法的对象employee，它是隐式参数。另一个参数是显式参数-double percent。可以在方法内部通过this关键字使用隐式参数。

```java
public void raiseSalary(double percent){
    double raise = salary * percent /100;
    this.salary += raise;
}
```

###### 4.3.6 封装的优点

将类的实例域设置为私有的有以下好处

* 安全性，只能通过类提供的方法修改实例域，可以在方法中进行参数检查，避免错误数据，而将实例域设置为共有的，则在任何地方都可以修改实例域。
* 便利性，只要保证访问器的返回值类型相同，我们可以随意更改私有数据的规则。

尽量不要在类中编写返回可变对象的访问器方法，参考以下代码：

```java
public class Employee {
    private Date hireDay;
    public Employee(Date hireDay) {
        this.hireDay = hireDay;
    }
    public Date getHireDay() {
        return hireDay;
    }
    public static void main(String[] args) {
        Employee employee = new Employee(new Date());
        Date d = employee.getHireDay();
        d.setTime(1000000);
    }
}
```

如以上代码，Date对象是一个可变对象，可以通过setTime()方法改变对象的时间，此时通过Employee类的getHireDay()方法获取到的对象d将和employee对象的hireDay实例域指向同一个对象，此时改变d的状态，employee对象的状态也将发生变化。（可以使用克隆优化）

###### 4.3.7 基于类的访问权限

一个对象在调用方法时，不仅可以使用自身的私有实例域，还可以使用相同类的其他对象的私有实例域。如equals()方法。

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Employee employee = (Employee) o;
    return Double.compare(employee.salary, salary) == 0 &&
            Objects.equals(name, employee.name) &&
            Objects.equals(hireDay, employee.hireDay);
}
```

###### 4.3.8 私有方法

在设计类时，不仅仅要将变量设置为私有的，有一些共有的方法可能由一些辅助方法共同完成，这些辅助方法应该被设计为私有的。私有方法可以随时删去，因为可以确保只有本类在使用，而公有方法可以在其他地方被使用，需要谨慎删除。

###### 4.3.9 final实例域

当final修饰类的实例域时，必须确保无论调用哪个构造器创建对象，该实例域都被赋值，可以在每个构造函数中赋值，也可以在代码块中赋值。被final修饰的变量，赋值后不可改变。如果final修饰的变量，是一个引用数据类型，代表该变量不可再引用其他对象，但该对象可以发生变化。

##### 4.4 静态域和静态方法

###### 4.4.1 静态域

当类中的变量域被static修饰时，类只有一个这样的域，而每个对象对于实例域拥有一份拷贝(即属于类，而不属于对象)。

###### 4.4.2 静态常量

静态变量使用的较少，但是静态常量却常常使用，如Math类中的静态常量PI、E等。使用时可以通过类直接访问`Math.PI`，如果不使用static修饰则需要创建一个对象才能访问。

###### 4.4.3 静态方法

静态方法时被static关键字修饰的方法，在使用时，不可以访问非static的实例域或方法。静态方法在使用时，没有隐式参数。

###### 4.4.4 工厂方法

静态方法还有一个用途，就是静态工厂方法，如LocalDate.now()和LocalDate.of()等。

###### 4.4.5 main方法

再Java中main是静态的，去掉static关键字无法执行。

##### 4.5 方法参数

按值调用是指方法接收的是调用者提供的值。

按引用传递指方法接收的是调用者提供的变量地址。

方法可以修改引用传递对应的变量值，而不能修改值传递对应的变量值，在Java中是按值调用。

Java中方法参数的使用情况：

* 一个方法不能改变一个基本数据类型的参数
* 一个方法可以改变对象的状态
* 一个方法不能让参数引用一个新的对象

##### 4.6 对象构造

对象的构造方法可以用来创建对象，因此十分重要，Java提供了很多机制编写构造方法，下面介绍一下这些机制。

###### 4.6.1 重载

重载是一个类中同名，但参数列表不同发生的一种行为，在方法调用时，编译器必须从重载的方法中挑选一个执行，这个过程叫做重载解析。Java中允许重载任何方法，包括构造方法。

在调用方法时，需要指出方法名和参数，这叫做方法的签名，返回值类型不是方法签名的一部分，因此类中不允许出现同名、同参数而返回值类型不同的方法。

###### 4.6.2 默认域初始化

如果在构造方法中没有显示的给实例域赋值，那么它们就会被赋初值。数值类型为0，布尔型为false，引用数据类型为null（与局部变量不同，局部变量不能被赋初值，需要手动赋值）

###### 4.6.3 无参的构造器

如果在编写类时，没有提供构造方法，那么将会默认提供一个无参构造方法，用来给实例域赋初值。如果类提供了构造方法(有参数)，则不再自动提供无参构造。

###### 4.6.4 显式域初始化

可以在构造方法之前队实例域进行初始化，赋值时可以使用方法。

```java
public class Employee {
    private String name = "hyy";
    private int id = nextId();
    private static int i = 0;
    private int nextId(){
        return Employee.i++;
    }
}
```

###### 4.6.5 参数名

在编写构造方法时，一般将参数名和实例域变量名保持一致，而在方法中使用this关键字进行区分。如下：

```java
public Employee(String name, double salary, LocalDate hireDay) {
    this.name = name;
    this.salary = salary;
    this.hireDay = hireDay;
}
```

###### 4.6.6 调用另一个构造器

在构造方法中，还可以调用另一个构造方法，一个构造方法调用另一个构造方法时必须放在第一行。

```java
public Employee(String name, double salary, LocalDate hireDay) {
    this.name = name;
    this.salary = salary;
    this.hireDay = hireDay;
}

public Employee(String name, double salary) {
    this(name,salary,LocalDate.now());
}
```

###### 4.6.7 初始化块

对实例域进行赋值操作除了构造方法和直接赋值外，还有第三种方式，初始化块。以下是初始化块的语法：

```java
public class Employee {
    private String name;
    private int age;
    {
        name = "hyy";
        age = 18;
    }
}
```

初始化块可以有多个，但是尽量将初始化块放在实例域声明之后。

以下是三种赋值的执行顺序：

* 所有数据域被赋初值
* 从上到下依次执行显式赋值语句和初始化块
* 执行构造方法，如果构造方法的第一行调用了其他构造方法，则执行被调用的构造。
* 执行构造方法其余部分

对类的静态数据域可以使用显式赋值也可以使用静态初始化块。如下

```java
public class Employee {
    private static int age;
    static {
        age = 18;
    }
}
```

在类第一次加载的时候会执行上述语句，与普通实例域一样，如果没有显式的初始化，它们将被自动的初始化为默认值。静态赋值语句和静态代码块也是从上到下依次执行的。

###### 4.6.8 对象析构和finalize()方法

析构方法是C++中的方法，其中放置的是对象不需要时所执行的清理代码，而Java中有自动垃圾收集器，因此不支持析构方法。finalize()方法是Java对象在被垃圾回收机制回收时需要执行的方法。

##### 4.7 包

Java支持以包的形式将类文件组织起来，为了保证包名的唯一性，默认以域名的倒叙为包名，如com.baidu，一个包下可以有多个子包。

###### 4.7.1 类的导入

一个类可以使用所属包中的所有类，以及其他包中的共有类，可以使用两种方法使用其他包中的类，一种是在类名前添加完整的包名，如：

```java
java.time.LocalDate localDate = java.time.LocalDate.now();
```

还有一种方法是使用import语句将其他包中的类进行导入。

```java
import java.time.LocalDate; //导入类
import java.time.*; //导入整个包
```

###### 4.7.2 静态导入

import不仅可以导入类，还可以用来导入静态资源，导入静态资源后，使用静态资源可以省略类名如：

```java
import static java.lang.Math.*;
Math.max(1,2); 
max(1,2); //静态导入后
```

###### 4.7.3 将类放入包中

将类放入包中需要将包名放在文件的开头，package语句之后，如：

```java
package com.hyyngu.code_8;
```

###### 4.7.4 包作用域

* Default   默认   包可见性
* protected 本类以及子类可见
* public 所有类可见
* private 本类可见

##### 4.8 类路径

略

##### 4.9 文档注释

JDK包含了一个很有用的工具，javadoc,它可以帮助我们抽取文档中的注释生产一个html文档。

###### 4.9.1 注释的插入

javadoc可以从以下位置抽取注释，因此应当为以下部分编写注释。

* 包
* 共有的类与接口
* 共有的和受保护的方法
* 共有的和受保护的域

注释以/**开始，以 */结尾，在此之间使用自由格式文本，可以使用Html标签。

###### 4.9.2 类注释

类注释必须放在improt之后，类声明之前。

###### 4.9.3 方法注释

方法注释在方法之前，可以使用@标记说明一些东西。

* @param 标记参数
* @retutn 标记返回值
* @throws 标记异常

###### 4.9.4 域注释

域注释一般是对共有实例域(一般是静态常量)进行注释

###### 4.9.5 通用注释

以下还有一些通用的标记

* @author 作者
* @version 版本号
* @since 起始标记，如起始于哪个版本
* @deprecated 将类或方法标记为不再使用
* @see 建立一个到某个类或方法的超链接

###### 4.9.6 包与概述注释

产生包注释有两种方式：

* 提供一个以 package.html命名的文件，<body></body>之间的内容将被抽取。
* 还可以提供一个package-info.java的文件，文件中只能有一个/**开头，和 */结尾的注释。

还可以为所有的源文件进行概述注释，概述注释被放置在所有源文件的父目录中，名为overview.html的文件中。

###### 4.9.7 注释的抽取

可以使用javadoc提供的命令提取注释。略。

##### 4.10 类设计技巧

* 一定要保证数据私有
* 一定要对数据进行初始化
* 不要在类中使用过多的基本数据类型
* 不是所有的数据都需要访问器方法和更改器方法
* 将职责过多的类分解
* 类名和方法名要能体现他们的职责
* 优先使用不可变的类 如：LocalDate和Date类的选择

#### 第五章 继承

##### 5.1 类、超类和子类

###### 5.1.1 定义子类

Java中的继承是由extends表示，表示继承一个已存在的类，这个类被称为超类、基类或父类，新类被称为子类、派生类或孩子类。

```java
public class Manager extends Employee{

}
```

子类可以继承并使用父类的方法和实例域，而父类不可以使用子类的方法和实例域，因此，在设计类时，一般将通用方法放在父类中，而将子类特殊的方法在子类中定义。

###### 5.1.2 覆盖方法

有时候父类的方法并不适用于子类，我们可以定义一个新的方法来覆盖父类的方法(重写)，重写方法时，如果需要访问父类的实例域，不可以直接访问，只能通过super关键字调用父类的访问器方法进行访问。

```java
public class Manager extends Employee{
    private int bounds;

    public void setBounds(int bounds) {
        this.bounds = bounds;
    }

    @Override
    public double getSalary(){
        return super.getSalary() + bounds;
    }
}
```

###### 5.1.3 子类构造器

可以在子类的构造器中调用通过关键字super调用父类的构造器。

```java
public class Manager extends Employee{
    private int bounds;
    public Manager(String name, double salary, LocalDate hireDay, int bounds) {
        super(name, salary, hireDay);
        this.bounds = bounds;
    }
}
```

由于子类不能直接访问父类的私有数据，无法为从父类继承的数据初始化，所以必须通过super调用父类的构造器对其进行初始化。Java会默认调用父类的无参构造对数据进行赋初值，如果父类没有无参构造，而子类也没有调用父类其他构造，那么将报错。

###### 5.1.4 继承层次

Java中只能继承一个父类，一个父类可以被多个类继承，子类也可以被其他类继续继承。

###### 5.1.5 多态

在继承关系is-a中，另一种表示法时置换原则，即父类可以被子类对象置换(即将子类对象赋值给父类变量)。在Java中对象变量是多态的，一个Employee变量既可以引用Employee类型的对象，也可以引用其子类类型的对象。相应的子类数组引用也可以赋值给父类数组。

###### 5.1.6 理解方法调用

理解方法调用的过程非常重要，下面假设调用x.f(args)，隐式参数声明为类C的对象。

* 编译器首先列出C类和父类中属性为public的且名称为f的方法
* 编译器根据提供的参数类型，在所有的方法中找到一个合适的方法(以上过程又被称之为重载解析)
* 如果是private、static、final修饰的方法或者构造器，那么可以准确地知道调用哪个方法，我们将这种绑定方式称之为静态绑定。与此对应的是，如果调用的方法依赖于隐式参数的实际类型，并且在运行时实现动态绑定
* 在程序运行时，将调用最符合x实际类型最符合的方法，如果D是C的子类，如果D类中定义了需要调用的方法，那么直接调用，否则在父类中寻找，以此类推。

为了减少搜索方法的时间虚拟机为每个类都创建了一个方法表，用来存放方法的签名和实际调用的方法。

###### 5.1.7 阻止继承:final类和方法

在Java中被final修饰的类将无法被继承，被final修饰的方法将不能被子类覆盖(重写)，在早期有些程序员为了避免动态绑定的系统开销而使用final关键字来修饰方法。

方法内联：如果一个方法没有被覆盖，且方法体很小，那么即时编译器即将会把方法进行内联处理(将方法体“复制”到调用该方法的地方)，减少创建栈帧的开销，提高系统效率。

###### 5.1.8 强制类型转换

与基本数据类型一样，Java中的引用数据类型也可以进行强制类型转换，可以将一个类的对象引用转换为另一个类的对象引用，其语法与基本数据类型进行强制类型转换的愈发一致。如果强制类型转换的两个类没有继承关系，那么编译器就会报错，如果试图将父类强制转换为子类引用，将会产生ClassCastException异常。

* 只能在继承层次内进行强制类型转换
* 父类引用转换为子类引用时需要使用 instanceof关键字检测实际类型，避免出现异常

###### 5.1.9 抽象类

Java中可以使用abstract关键字定义抽象方法，包含一个或多个抽象方法的类必须被定义为抽象类，抽象类有以下特点：

* 抽象类可以没有抽象方法
* 抽象类中可以有实例域和普通方法
* 不能通过new关键字创建抽象类的实例，而是需要创建具体的子类对象。

子类继承抽象类时有两种方式：

* 实现父类中的所有抽象方法
* 不实现或实现父类中的一部分抽象方法，但是需要将子类也定义为抽象类

###### 5.1.10 受保护访问

有时候子类需要访问父类中的方法或变量，此时可以将这些方法或变量修饰符设置为protected的。Java中的访问权限修饰符：

* private 私有的只有本类可以访问
* protected 包和子类可见性
* public 共有的，所有类可见
* default 默认的(可以不写) 包可见性

##### 5.2 Object：所有类的超类

在Java中Object类是所有类的超类，如果没有继承父类，那么将默认继承Object类

###### 5.2.1 equals()方法

Object类中的equals()方法用来判断一个对象是否等于另一个对象，默认的实现是判断两个对象是否具有相同的引用。可以重写equals方法来自定义类的比较规则。

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Employee employee = (Employee) o;
    return Double.compare(employee.salary, salary) == 0 &&
            Objects.equals(name, employee.name) &&
            Objects.equals(hireDay, employee.hireDay);
}
```

通常在子类中还需要调用父类的equals方法判断从父类中继承的域是否相等。

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    if (!super.equals(o)) return false;
    Manager manager = (Manager) o;
    return bounds == manager.bounds;
}
```

###### 5.2.2 相等测试与继承

Java语言规范规定equals有以下特性

* 自反性：对任何非空引用x,x.equals(x)应该返回true
* 对称性：对任何引用x,y，当且仅当x.equqls(y)返回true时，y.equals(x)也应返回true
* 传递性：对任何引用x,y,z,如果x.equals(y)返回true，且y.equals(z)返回true,那么x.equals(z)返回true
* 一致性：如果x,y的引用没有发生变化，那么无论何时调用都应返回相同的结果
* 对任何非空引用x,x.equals(null)返回false

在对两对象的实际类型进行检测时，可以使用instanceof关键字或getClass()方法。

由对称性可知使用instanceof进行检测时，无法满足对称性，employee instanceof Manager将返回false,反过来将返回true。

两种方式，在选择时有以下技巧：

* 如果由子类自己定义自己相等的概念，则使用getClass()检测。
* 如果由超类定义相等概念，则应使用instanceof关键字检测，这样可以在不同子类间进行比较

###### 5.2.3 hashCode()方法

散列码 (hash code)是由对象导出的整型值，如果x,y是不同的对象，那么其散列码几乎不会相同，hashCode()方法是Object类的一个方法，因此每个对象都有一个默认的散列码，其值为对象的存储地址。

如果重新定义了equals()方法,那么必须重新定义hashCode()方法，以便将对象插入到哈希表中。

###### 5.2.4 toString()方法

Object类还有一个重要的方法，toString()方法，这个方法用来返回对象的字符串表示形式。

```java
@Override
public String toString() {
    return "Employee{" +
            "name='" + name + '\'' +
            ", salary=" + salary +
            ", hireDay=" + hireDay +
            '}';
}
```

##### 5.3 泛型数组列表

Java提供了一些在运行时可以动态扩容的泛型数组，如ArrayList类，它是一个带有参数类型的泛型类。声明格式如下:

```java
ArrayList<Employee> arrayList = new ArrayList<>();
```

可以使用add()方法向数组中添加元素，如果数组已满则会创建一个更大的数组，并将原数组的内容拷贝进去。

```java
Employee employee = new Manager();
ArrayList<Employee> arrayList = new ArrayList<>();
arrayList.add(employee);
```

###### 5.3.1 访问数组列表元素

可以使用get()和set()方法来访问数组列表中的元素。

```java
int index = 0;
arrayList.get(index); //获取索引为index位置的元素
arrayList.set(index,new Employee()); //将索引为index位置的值设置为新的值
```

以下是ArrayList类的常用方法：

* boolean add(E obj)   向列表末尾添加一元素
* int size()  返回列表当前元素数量
* void trimToSize() 删除多余的空间
* void set(int index,E obj) 设置索引位置的元素为新的值
* E get(int index) 获取指定位置的值
* void add(int index,E obj) 指定位置添加元素
* E remove(int index) 移除指定位置元素

###### 5.3.2 类型化与原始数组列表的兼容性

指的是与Java早期没有泛型数组的遗留代码的兼容性,略。

##### 5.4 对象包装器与自动装箱

Java中所有的基本数据类型都有一个类与之一一对应，这些类被称之为包装器，如Byte、Short、Integer、Long、Float、Double、Character、Void和Boolean。对象包装器在构造之后无法改变其中的值。

在包装器与基本数据类型之间存在自动装箱与拆箱，编译器在编译时会自动插入相应的装箱拆箱语句。

由于Java是值传递，且包装在包装器中的值无法改变，因此使用基本数据类型和包装器都无法编写一个用于改变数值的方法。可以使用org.omg.CORBA包中定义的持有者类型(holder)，如：IntHolder、BooleanHolder

```java
public static void main(String[] args) {
    IntHolder x = new IntHolder(3);
    add(x);
    System.out.println(x.value); // 4
}
private static void add(IntHolder x){
    x.value++;
}
```

##### 5.5 参数数量可变的方法

在Java中，如果不确定方法参数的数量有两种形式，一是使用数组形式，二是使用可变的参数列表，两种形式如下

```java
private void sort(int[] arr){
    
}
private void sort(int...arr){

}
```

##### 5.6 枚举类

在Java中的枚举类中可以定义方法，构造器和实例域。

```java
public enum Size {
    SMALL("S"),MEDIUM("M");
    private String value;
    Size(String v){
        this.value = v;
    }
    public String getValue() {
        return value;
    }
}
String value = Size.SMALL.getValue();
System.out.println(value); //S
```

##### 5.7 反射

Java中的反射库提供了一个工具集，利用这些工具集，我们可以在运行时动态的分析类，或者添加新类，这种分析类的能力称为反射，反射可以用来：

* 在运行时分析类的能力
* 在运行时查看对象
* 实现通用的数组操作代码
* 利用Method对象

###### 5.7.1 Class类

在程序运行期间，虚拟机为每个Java对象维护了一个运行时类型标识，这个信息跟踪了对象所属的类，保存这些信息的类是Class类，可以通过Object类的getClass()方法得到对象所属的类的实例。

```java
Employee employee = new Employee();
Class c = employee.getClass();
```

可以使用getName()方法获取类的名称(包括包名)

```java
Employee employee = new Employee();
Class c = employee.getClass();
System.out.println(c.getName()); //com.hyyngu.code_8.Employee
```

还可以使用静态方法forName()通过类名获取Class类的实例。

```java
Class c = Class.forName("com.hyyngu.code_8.Employee");
```

获取Class对象的第三种方法是通过类名获取，形式如下：

```java
Class c = Employee.class;
```

Class类的实例表示的不一定是一个类的对象，而是类型对象，如int.class。

在虚拟机中，每个类型的Class对象只有一个，因此可以获取对象的Class信息，判断两个对象是否属于同一类型。

可以使用Class对象的newInstance()方法创建一个该类的实例，newInstance()方法将调用类的无参构造，若该类没有无参构造，将会报错。

###### 5.7.2 捕获异常

当程序在运行过程中发生错误时，就会抛出异常，抛出异常比终止程序灵活得多，因为可以提供一个异常处理器，对异常进行处理。

异常有两种类型：未检查异常和已检查异常，对于已检查异常，编译器会检查是否为其添加了异常处理器。可以使用try...catch语句来捕获处理异常。如果try块中的语句出现异常，则会跳过其他语句，执行catch块中的异常处理语句。

```java
try {
    Employee employee = new Employee();
    Class c =  Class.forName("com.hyyngu.code_8.Employee");
}catch (Exception e){
    e.printStackTrace();
}
```

###### 5.7.3 利用反射分析类的能力

在Java的反射包java.lang.reflect包中有三个重要的类，Filed、Method和Constructor，分被用于描述类的实例域、方法和构造器。通过Class类的getFileds()、getMethods()和getConstructors()方法可以获取类的public实例域、方法和构造器，包括父类公有的成员。

getDeclaredFileds()、getDeclaredMethods()和getDeclaredConstructors()方法将返回类中的全部实例域方法和构造器，包括受保护的，但是不包括父类的。以下是分析类的一个实例：

```java
public class Fathor {
    private String name;
    protected int age;
    public int id;
    public Fathor() {
    }
    public Fathor(String name, int age, int id) {
        this.name = name;
        this.age = age;
        this.id = id;
    }
    public String fathorPublicMethod(){
        return "fathorPubM";
    }
    private String fathorPrivateMethod(){
        return "fathorPriM";
    }
    protected String fathorProtectedMethod(){
        return "fathorProM";
    }
    private class Son extends Fathor{
        private int x;
        public int y;
        protected String z;
        public Son() {
        }
        public Son(int x, int y, String z) {
            this.x = x;
            this.y = y;
            this.z = z;
        }
        public String sonPublicMethod(){
            return "sonPubM";
        }
        private String sonPrivateMethod(){
            return "sonPriM";
        }
        protected String sonProtectedMethod(){
            return "sonProM";
        }
    }
    public static void main(String[] args) {
        Class sonClass = Son.class;
        int modifiers = sonClass.getModifiers();  //修饰符
        System.out.println(Modifier.toString(modifiers) + " class " + sonClass.getName());
        System.out.println("---------------------------");
        Field[] fields = sonClass.getFields();
        for (Field field : fields) {
            String modifier = Modifier.toString(field.getModifiers());
            String type = field.getType().getName();
            String name = field.getName();
            System.out.println(modifier + " " + type +" "+ name);
        }
        System.out.println("---------------------------");
        Constructor[] constructors = sonClass.getConstructors();
        for (Constructor constructor : constructors) {
            String modifier = Modifier.toString(constructor.getModifiers());
            String name = constructor.getName();
            Class[] parameterTypes = constructor.getParameterTypes();
            StringBuilder sb = new StringBuilder().append("(");
            for (Class c : parameterTypes) {
                sb.append(c.getName()).append(" ");
            }
            sb.append(")");
            System.out.println(modifier  +" " +name + " " +sb.toString());
        }
        System.out.println("---------------------------");
        Method[] methods = sonClass.getMethods();
        for (Method method : methods) {
            String modifier = Modifier.toString(method.getModifiers());
            String returnType = method.getReturnType().getName();
            String name = method.getName();
            Class[] parameterTypes = method.getParameterTypes();
            StringBuilder sb = new StringBuilder().append("(");
            for (Class c : parameterTypes) {
                sb.append(c.getName()).append(" ");
            }
            sb.append(")");
            System.out.println(modifier +" "+ returnType +" " +name + " " +sb.toString());
        }
    }
}
```

###### 5.7.4 在运行时使用反射分析对象

上边的代码分析了类的实例域，还可以进一步的查看或设置对象中实例域的实际内容。代码如下：

```java
public static void main(String[] args) {
    try {
        Class c = Employee.class;
        Employee employee = new Employee("hyy",18,LocalDate.now());
        Field field = c.getDeclaredField("name");
        field.setAccessible(true);  //私有域不能访问，需要获取权限
        String name = (String) field.get(employee);
        System.out.println(name);
        field.set(employee,"yyh");
    }catch (Exception e){
        e.printStackTrace();
    }
}
```

###### 5.7.5 使用反射编写泛型数组代码

有时候，一些一开始就声明为Object类型的数组，不能强制类型转换为具体的类型数组，此时需要使用反射创建泛型类型的数组。如编写一个扩容任意类型的数组的方法。

```java
public static void main(String[] args) throws Exception{
    Employee[] employee = new Employee[1];
    Object[] objects = copyOfBad(employee);
    employee = (Employee[]) objects;        //ClassCastException
}
private static Object[] copyOfBad(Object[] objects){
    Object[] object = new Object[objects.length << 1];
    System.arraycopy(objects,0,object,0,objects.length);
    return object;
}
```

以上的代码会产生类型转换异常，需要使用反射包中的Array类的newInstance()方法来完成。

```java
public static void main(String[] args) throws Exception{
    Employee[] employee = new Employee[1];
    Object objects = copyOfGood(employee);
    employee = (Employee[]) objects; //ClassCastException
}
private static Object copyOfGood(Object[] objects){
    Object object = Array.newInstance(objects.getClass().getComponentType(),objects.length <<1);
    System.arraycopy(objects,0,object,0,objects.length);
    return object;
}
```

###### 5.7.6 调用任意方法

在Java中还可以使用反射包中Method类的invoke(Object obj, Object...args)调用任意的方法，obj为显式参数，args为显示参数，两个参数缺一不可，如果为静态方法则obj可以传null，如果没有参数，则args可以传null。

```java
public static void main(String[] args) throws Exception{
    Employee employee = new Employee("hyy",18,LocalDate.now());
    Class c = employee.getClass();
    Method method = c.getMethod("setName", String.class);
    method.invoke(employee,"yyh");
    System.out.println(employee.getName());   //yyh
}
```

##### 5.8 继承设计技巧

* 将公共操作和域放在父类中
* 不要使用受保护的域
* 使用继承实现is-a关系
* 除非所有继承的方法有意义，否则不要继承
* 覆盖方法时，不要改变预期的行为
* 使用多态，而非类型信息
* 不要过多的使用反射

#### 第六章 接口、lambda表达式和内部类

接口是用来描述实现接口的类应该具有哪些功能，而不必给出这些功能的实现，一个类可以使用implements关键字实现一个或多个接口。

##### 6.1 接口

###### 6.1.1 接口概念

在Java中接口不是类，而是对类的需求的规范，实现接口的类，必须遵守该规范。如：Arrays类中的sort()方法可以对对象数组进行排序，但前提是该对象的类实现了Comparable接口，任何对象实现该接口都需要实现其中的方法compareTo()方法，对两对象进行比较大小。

接口中的方法自动的声明为public，不需要手动提供关键字，接口中可以定义常量，不可以定义实例域。

为了让类实现一个接口，需要完成以下两步：

* 在类上使用implements关键字实现接口
* 对接口中的所有方法进行实现

```java
public class Employee implements Comparable{
	@Override
    public int compareTo(Object o) {
        Employee other = (Employee)o;
        return Double.compare(this.getSalary(),other.getSalary());
    }
}
```

###### 6.1.2 接口的特征

接口不是类不能使用new关键字创建接口的实例，但是可以声明接口类型的变量，该变量只能引用实现该接口的类，可以使用instanceof关键字检测对象是否实现了接口，接口可以继承，而且可以多继承。接口中不能有实例域，可以有常量，接口中的方法自动被声明为public，域自动被设置为public static final的，类可以实现多个接口。

###### 6.1.3 接口与抽象类

Java中的类只能继承一个父类，可以实现多个接口，而且使用接口比使用多继承效率要高，使用也更加简单。

###### 6.1.4 静态方法

在Java8中可以为接口添加静态方法，但是这样设计违背了接口的初衷。目前并没有用到这种特性，通常的做法是为接口设计伴随类，如jdk类库中的Collection/Collections、Path/Paths。

###### 6.1.5 默认方法

可以在接口中定义一个默认的实现，但是该方法必须用default修饰。如下：

```java
public interface C{
    default void defaultMethod(){
        System.out.println("接口默认方法");
    }
}
```

当为接口增加一个新方法时，将该方法声明为默认方法可以保证之前的实现了该接口的类依然能编译运行。

###### 6.1.6 解决默认方法冲突

当接口中的默认方法与父类中的方法冲突时，默认使用以下规则解决：

* 父类优先，当接口中的方法与父类中的方法同名同参数时，默认使用父类的，忽略接口的。
* 接口冲突，当类继承的两个接口中出现了同名同参数的方法时，该类必须覆盖该方法以解决冲突。

##### 6.2 接口实例

###### 6.2.1 接口与回调

回调是一种常见的程序设计模式，在这种模式中，可以指定某个特定事件发生时，程序应该采取怎样的动作，java.swing包中有一个定时器Timer，可以在指定的时间间隔到达后做出响应，需要将一个实现ActionListener接口的对象传递给定时器。

```java
public class AListener implements ActionListener {
    @Override
    public void actionPerformed(ActionEvent e) {
        System.out.println("定时任务");
    }
    public static void main(String[] args) {
        Timer timer = new Timer(1000,new AListener());
        timer.start();
        JOptionPane.showMessageDialog(null,"exit");
    }
}
```

###### 6.2.2 Comparator接口

Arrays类的sor()方法在进行排序的时候，不仅可以接收一个实现了Comparable接口的实现类数组，还可以使用第二种方式，传递一个数组和一个比较器，比较器是实现了Comparator的接口。如：根据字符串长度比较大小。

```java
public class LengthCompare implements Comparator<String> {
    @Override
    public int compare(String o1, String o2) {
        return o1.length() - o2.length();
    }

    public static void main(String[] args) {
        String[] strings = {"i","am","a","boy"};
        Arrays.sort(strings,new LengthCompare());
        for (String s:strings) {
            System.out.println(s);
        }
    }
}
```

###### 6.2.3 对象克隆

首先回忆一下为一个对象引用的变量建立副本的操作，新变量将会和原来的变量引用相同的对象，任何一个对象的改变都会影响另外一个，如果需要建立一份copy而使两个变量拥有不同的引用，就需要实现Cloneable接口的clone()方法。

```java
public static void main(String[] args) throws Exception{
    Employee employee = new Employee("hyy",18,LocalDate.now());
    Employee copy = employee;
    copy.setName("yhy");
    System.out.println(employee.getName());  //yhy
    Employee clone = (Employee) employee.clone();
    clone.setName("yyh");
    System.out.println(employee.getName()); //yhy
}
```

以上使用的是从Object类继承的clone()方法,该方法是一个浅拷贝，如果对象的实例域有对其他对象的引用，那么克隆对象的实例域和该对象的实例域引用的是同一个对象。如果存在这种问题，则需要重写Object类的clone()方法。对于每个类，我们需要确定：

* 默认的浅克隆是否满足需求
* 是否可以在可变的对象上调用clone来修补默认的clone方法。
* 是否不该使用clone

如果类必须使用深克隆，那么必须：

* 实现Cloneable接口
* 重写clone()方法，并指定修饰符为public(这样在其他类中也能克隆)

Cloneable接口中没有方法，在Java中这种接口称为标记接口，这样可以在程序中使用instanceof关键字进行检测，这样如果对没有实现Cloneable接口的类调用clone()方法就会抛出异常。

##### 6.3 lambda表达式

lambda是Java8的新特性，是一个语法糖。

###### 6.3.1 为什么引入lambda表达式

lambda是一个可传递的代码块，可以在以后执行一次或多次，如ActionListener实现类的actionPerformed()方法，Arrays类的sort方法会多次调用比较器的compare()方法。为了避免定义类，然后编写实现方法方法的繁琐性，引入了lambda将这种代码块进行传递。

###### 6.3.2 lambda表达式的语法

lambda表达式的语法如下：

``` java
Arrays.sort(strings,(String a,String b)->{
    return a.length() - b.length();
});  
//lambda表达式语法
//(String a,String b)->{ 
//	return a.length() - b.length();
//}
```

即使lambda表达式没有参数，依然要编写小括号。

```java
()->{
    for (int i = 0; i < 10; i++) {
        System.out.println(i);      
    }
};
```

如果可以推导出参数类型，则可以省略参数类型。

```java
Comparator<String> comp =  (a,b)->{
    return a.length() - b.length(); 
};
```

如果只有一个参数且类型可以推导出，则可以省略小括号和参数类型。

```java
ActionListener ac = event ->{
    
};
```

###### 6.3.3 函数式接口

对于只有一个抽象方法的接口，在使用时可以传递一个lambda表达式，这种接口被叫做函数式接口。lambda表达式的作用就是可以转换为函数式接口。

###### 6.3.4 方法引用

有时可能已经有现有的方法可以完成需求，此时可以将一个方法引用传递到lambda表达式中。如：

```
ActionListener ac = event ->{ System.out.println(event); };
```

```java
ActionListener ac = event ->{ System.out.println(event); };
ActionListener ac = System.out::println;
```

System.out::println就是一个方法引用，等同于event ->{ System.out.println(event); }。

使用方法引用主要有以下三种形式：

* object::instanceMethod
* Class::staticMethod
* Class::instanceMethod

对于前两种方式，方法引用等同于lambda表达式，对于第三中方式，lambda表达式的第一个参数会作为隐式参数来调用该方法。在方法引用中可以使用this关键字和super关键字。

###### 6.3.5 构造器引用

构造器引用和方法引用很类似，只不过构造器引用的方法名为new。如:Employee::new。

###### 6.3.6 变量作用域

lambda表达式可以使用表达式体所在块可以使用的变量，但是有一个问题，lambda表达式能不会立即执行，如之前的定时监听器，那么lambda如何保存变量呢？首先来看lambda的组成部分：

* 一个代码块
* 参数
* 自由变量的值，不在lambda表达式中定义的值

lambda表达式将在自由变量的区域存储自由变量的值。lambda表达式中只能使用不可变的变量。lambda表达式不能定义和局部变量同名的变量，lambda表达式中的this关键字指的是定义lambda表达式体的this。

###### 6.3.7 处理lambda表达式

使用lambda表达式的重点是延迟执行，如：

* 在一个线程中运行的代码
* 多次运行的代码
* 在算法适当位置运行的代码
* 发生某种事件执行的代码
* 只在必要时允许的代码

###### 6.3.8 再谈Comparator接口

Comparator接口有很多静态方法来创建比较器，这些方法可以用以lambda表达式或者方法引用。静态的comparing()方法将会提取对象的实例域进行比较可以使用thenComparing()方法链接下一个字段的比较。如下：

```java
Employee[] employees = new Employee[10];
Arrays.sort(employees,Comparator.comparing(Employee::getName).thenComparing(Employee::getSalary));
```

如果对象的该键可能为null,则还可以指定nullsFirst，和nullsLast指定null值比正常值大，还是小。

```java
Comparator<String> comparator = Comparator.naturalOrder();
Arrays.sort(employees,Comparator.comparing(Employee::getName,Comparator.nullsFirst(comparator)));
```

静态的reverseOrder()方法将会返回正常顺序的逆序排序，也可以使用naturalOrder的reverse()方法。

##### 6.4 内部类

内部类是定义在一个类内部的类，使用内部类可以访问类所在的定义域中的数据，包括私有变量，内部类可以对同一个包中的其他类隐藏起来。

###### 6.4.1 使用内部类访问对象状态

首先声明一个内部类，代码如下：

```java
public class TalkingColck {
    private int time;
    private boolean beep;

    public TalkingColck(int time, boolean beep) {
        this.time = time;
        this.beep = beep;
    }

    public void start(){
        TimerPrint timerPrint = new TimerPrint();
        Timer timer = new Timer(time,timerPrint);
        timer.start();
    }

    class TimerPrint implements ActionListener {
        @Override
        public void actionPerformed(ActionEvent e) {
            System.out.println("This time is " + new Date());
            if (beep)
                Toolkit.getDefaultToolkit().beep();
        }
    }

    public static void main(String[] args) {
        TalkingColck talkingColck = new TalkingColck(1000,false);
        talkingColck.start();
        JOptionPane.showMessageDialog(null,"退出？");
    }
}
```

可以看到，内部类不仅能使用自身的变量还可以访问其所在外部类的实例域。如beep变量。内部类的实例总有一个指向创建它的外部类实例的隐式引用outer,这个引用是不可见的(编译器修改了内部类的构造方法，添加了一个外部类的引用，在创建内部类的实例时，会将创建内部类的外部类实例引用传入构造方法)。可以将内部类声明为私有的，也只有内部类可以为私有类，常规类只能为包可见或共有的。

###### 6.4.2 内部类的特殊语法规则

内部类含有一个指向外部类的引用outer，但实际上语法稍微复杂一些。表达外部类引用的具体语法为：OuterClass.this，如上例中可以在内部类中使用`TalkingClock.this` 引用外部类实例。反过来，可以使用外部类实例使用OuterObject.new语法创建内部类对象。如`TalkingColck.TimerPrint timerPrint = talkingColck.new TimerPrint();` 

内部类中的静态域必须为final的，而且内部类中不能有静态方法。 

###### 6.4.3 内部类是否安全、是否有必要使用

内部类可以访问外部类的私有域，那么内部类是如何进行访问的呢？编译器在进行编译时会为外部类一个静态方法，内部类通过其隐式引用outer对象，调用该方法得到外部类的私有域。

###### 6.4.4 局部内部类

可以在方法中定义一个局部内部类，如上一节的示例可以修改为：

```java
public void start(){
    class TimerPrint implements ActionListener {
        @Override
        public void actionPerformed(ActionEvent e) {
            System.out.println("This time is " + new Date());
            if (beep)
                Toolkit.getDefaultToolkit().beep();
        }
    }
    TimerPrint timerPrint = new TimerPrint();
    Timer timer = new Timer(time,timerPrint);
    timer.start();
}
```

局部类不能用private或者public这样的访问修饰符修饰，它的作用域也被限定到这个方法中，局部还有一个优点是，除了该方法，其他区域的代码不知道该类的存在。

###### 6.4.5 由外部方法访问变量

局部类不仅可以访问对象的实例域，还可以访问方法的局部变量，但是该变量必须是不可变的。编译器会为局部类实例保存局部变量的副本，为了使局部变量和副本保持一致，局部类只能访问不可变的局部变量。

###### 6.4.6 匿名内部类

如果有时候只需要创建一个类的一个对象，那么可以使用匿名内部类，其语法为：

```java
public void start(){
    ActionListener timerPrint = new AListener(){
        @Override
        public void actionPerformed(ActionEvent e) {
            System.out.println("This time is " + new Date());
            if (beep)
                Toolkit.getDefaultToolkit().beep();
        }
    };
    Timer timer = new Timer(time,timerPrint);
    timer.start();
}
```

由于构造器的名字和类名相同，所以匿名内部类没有构造器，而是将参数传递给超类构造器，而当匿名内部类实现接口时，不能有参数。

匿名内部类在集合中还有一个作用就是双括号初始化：

```java
ArrayList<Integer> list = new ArrayList<Integer>(){
    {
        add(1);
        add(2);
    }
};
```

相当于在匿名内部类中定义了一个初始化块。

注：在equals()方法中经常需要调用getClass()方法进行类型判断，对匿名内部类调用将会失效。

在进行如是输出时，可能需要打印类名，可以调用this.getClass()方法，但是静态方法没有this参数，可以使用静态内部类获取语法如下：`new Object(){}.getClass().getEnclosingClass()`建立一个Object类的匿名子类，getEnclosingClass()将得到其外围类。

###### 6.4.7 静态内部类

有时候使用内部类是为了把一个类隐藏到一个类的内部，并不需要访问外部类的实例域，可以将内部类声明为静态的。(只有内部类可以声明为静态的)，静态内部类可以有静态域和方法。声明在接口中的内部类自动是静态的。

##### 6.5 代理

利用代理可以在运行时创建一个实现了指定接口的实现类。

###### 6.5.1 何时使用代理

假设有一个类的引用(或接口的引用)，它的确切类型无法在编译期确定，需要使用newInstance()方法或反射找到构造器，然而不能实例化一个接口，需要在运行时创建一个新类，为了实现此功能，可以使用代理创建代理类，代理类用含有接口指定的全部方法，和Object类的全部方法。然而不能在运行时定义这些方法的代码，而是提供一个invocation handler调用处理器。调用处理器中有一个invoke()方法，调用代理对象的方法时，会调用该方法，并将Method对象和参数传递给该方法。

###### 6.5.2 创建代理对象

想要创建一个代理对象，需要调用Proxy类中的newProxyInstance方法，这个方法有三个参数：

* 一个类加载器
* 一个Class类型的数组，每个元素是要实现的接口
* 一个调用处理器

创建代理对象后，调用代理对象的方法时，调用处理器的invoke()方法就会执行。

###### 6.5.3 代理类的特性

所有的代理类都扩展了Proxy类，一个代理类只有一个实例域，就是调用处理器，代理类的附加属性应该定义在处理器类中。对同一个类加载器和一组接口来说，只能有一个代理类。代理类一定是Public final的，如果这一组接口都是Public的，那么代理类不适于某个包，如果接口是非公有的，那么所有非公有有的接口必须在同一个包下，且代理类属于这个包。

#### 第七章 异常、断言和日志

对于异常，Java使用一种异常处理的错误捕获机制处理。

##### 7.1 异常

对于程序来说，如果在运行期间出现了异常，那么应该：

* 返回到一种安全状态，并使用户执行一些其他命令。
* 允许用户保存操作结果，并以妥善的方式终止程序。

异常处理的任务是将控制权从错误代码处，转移到处理此异常的处理器。一般程序中会出现以下异常：

* 用户输入错误
* 设备错误
* 物理限制
* 代码错误

在Java中，如果方法不能正常结束，方法就会退出(不返回任何值)，并且抛出一个异常，异常处理机制搜索可以处理该异常的处理器处理该异常。

###### 7.1.1 异常分类

所有的异常都是由Throwable类继承而来，Throwable子类分为了两个分支Error和Exception。Error是运行时的系统错误，不应该抛出此类型的对象，如果出现这种情况，除了尽可能地使程序安全的终止外，就再也无能为力了。我们需要关注的是Exception的结构。这个层次分为两个分支，一个是RuntimeException,另一个分支是其他异常。

RuntimeException类型的异常包含以下几种情况：

* 数组越界
* 错误的类型转换
* 空指针

其他的异常包括

* 试图在文件结尾继续读取数据
* 试图打开一个不存在的文件
* 通过字符串查找Class对象，但是类不存在。

Java语言将所有派生于Error类和RuntimeException类的异常称为非受查异常，其他异常称为受查异常。编译器将检查是否为受查异常提供了处理器。

###### 7.1.2 声明受查异常

一个方法不仅要告诉编译器要返回什么类型的值，还应告诉编译器会发生什么错误。方法应该在其首部声明所有可能的受查异常。在遇到下面四种情况时需要抛出异常：

* 调用一个抛出受查异常的方法。
* 程序运行过程中发现错误，并用throw语句抛出受查异常。
* 程序出现错误，如空指针异常等非受查异常
* 虚拟机或类库内部错误

对于前两种情况，必须告诉其他调用该方法的程序员可能发生的异常，如果一个方法可能抛出多个异常，必须在方法首部声明所有可能发生的异常，每个异常类用逗号隔开。如下：

```java
private void readFile(int a,int b) throws EOFException, FileNotFoundException {

}
```

一般不推荐声明非受查异常。如果没有声明或处理所有的受查异常，编译器会给出警告。

当子类覆盖父类的方法时，只能声明和父类相同的异常或该异常的子类，或者不声明异常，如果父类方法没有声明异常，子类也不能声明异常。

如果一个方法声明了异常，那么可能发生该异常，或该异常的子异常。

###### 7.1.3 如何抛出异常

可以使用throw语句抛出一个具体的异常对象，如下：

```java
throw new IOException();
//或者
IOException e = new IOException();
throw e;
```

还可以使用带参数的构造器，描述异常情况。

```java
throw new FileNotFoundException("文件找不到");
```

当抛出异常时，将会调用Throwable继承的toString()方法输出构造器中的异常信息。

总结：方法抛出分为三步：

* 找到一个而合适的异常类
* 创建一个异常类对象
* 抛出该对象

一旦抛出了异常，方法就不会返回到调用者了，也就不用担心返回值了。

###### 7.1.4 创建异常类

如果类库中的异常类无法满足要求时，我们还可以定义自己的异常类，只需要定义一个继承Exception或Exception的子类，然后提供两个构造器，无参构造，和带详细信息的构造器。

##### 7.2 捕获异常

###### 7.2.1 异常捕获

想要捕获一个异常，必须使用try/catch语句块。最简单的try/catch语句块如下：

```java
try {
    
}catch (Exception e){
    
}
```

如果程序在try语句块中，发生了catch语句中声明的异常，那么程序将：

* 跳过try语句块中剩余的代码
* 执行catch语句块中的内容

如果在try语句块中没有发生任何异常，那么程序将跳过catch语句块。

如果发生了catch语句块中没有声明的异常，那么程序将立即退出。

个人理解：抛出异常是声明出方法可能发生的异常，并将异常抛出给方法的调用者处理，而捕获异常是对程序发生的异常自己处理。

通常将知道如何处理的异常进行捕获，而将不知道如何处理，或不确定如何处理的异常进行抛出。（如果要重写父类的方法，而不抛出异常，就需要捕获处理父类中抛出的所有受查异常）

###### 7.2.2 捕获多个异常

在一个try语句块中可以捕获多个异常类型，并针对不同的异常类型进行不同的处理。代码格式如下：

```java
try {

}catch (FileNotFoundException e){

}catch (IOException ioe){
    
}
```

如果多个异常的处理方式是一样的，那么还可以对catch语句进行合并。代码如下：

```java
try {

}catch (FileNotFoundException | IOException ioe){

}
```

在使用上述代码捕获多个异常时，异常变量隐式的为final的。

###### 7.2.3 再次抛出异常与异常链

可以在catch语句中抛出异常，这样做的目的通常是为了改变异常的类型。代码如下：

```java
try {

}catch (SQLException e){
    throw new ServletException("error message:" + e.getMessage());
}
```

这里使用带有异常信息参数的构造器来构造异常，还有一种更好的方式是使用原始的异常类并设置其异常原因。代码如下：

```java
try {

}catch (SQLException e){
    Throwable se = new Throwable("error message:");
    se.initCause(e);
    throw se;
}
```

当捕获到异常时，可以使用`Throwable e = se.getCause()` 得到原始异常。建议使用此方式。

如果在一个方法中发生了一个受查异常，而不允许抛出它，那么包装技术就十分有用了，我们可以捕获这个异常，并将其包装成为一个运行时异常。

###### 7.2.4 finally子句

当一段代码抛出异常时，就会终止剩余代码的处理，并退出方法的执行，如果在此之前程序获得了一些资源，那么必须对这些资源进行释放，此时我们可以使用finally子句。代码如下：

```java
FileInputStream in = new FileInputStream("");
try {
    
}catch (FileNotFoundException e){
    throw new RuntimeException(e.getMessage());
}finally {
    in.close();
}
```

无论try中的语句是否发生异常，finally语句块中的语句都将被执行。

try语句后可以只有finally语句，而没有catch语句，建议结合使用try/catch，和try/finally语句块进行资源的释放。以提高代码的清晰度。代码如下：

```java
try {
    FileInputStream in = new FileInputStream("");
    try{
        
    }finally {
        in.close();
    }
}catch (FileNotFoundException e){
    throw new RuntimeException(e.getMessage());
}
```

###### 7.2.5 带资源的try语句

如果资源是一个实现了AutoCloseable接口的类，那么我们可以使用带资源的try语句进行资源的释放。还有一个AutoCloseable接口的子接口Closeable接口，两者的不同点是抛出的异常不同。

* ```java
  void close() throws Exception; // AutoCloseable
  ```

* ```java
  public void close() throws IOException; // Closeable
  ```

带资源的try语句写法如下：

```java
try (FileInputStream in = new FileInputStream("")){

}catch (FileNotFoundException e){
    throw new RuntimeException(e.getMessage());
}
```

带资源的try语句也可以有catch子句和finally子句，这些字句将在资源被关闭后执行。

###### 7.2.6 分析堆栈轨迹元素

堆栈是程序执行过程中方法调用的列表，可以使用Throwable类的printStackTrace()方法打印堆栈信息。，也可以使用getStackTrace()方法获取堆栈数组进行详细分析。还可以使用静态的Thread.getAllStackTrace()方法获取多有线程的堆栈信息。

##### 7.3 使用异常机制的技巧

* 异常处理不能代替简单的测试(尽量只在异常情况下使用异常)
* 不要过分的细化异常
* 利用异常层次结构
* 不要压制异常
* 在检测错误时，苛刻比放任更好

##### 7.4 使用断言

###### 7.4.1 断言的概念

断言机制允许在测试期间向代码中插入一些检查语句，当代码发布时，这些语句将被自动的移除走。断言有两种写法：

* assert 条件；
* assert 条件：表达式；

这两种形式都会对条件进行检测，如果为false,将会抛出AssertionError错误，在第二种形式中，表达式将会被转换为消息字符串传递进入AssertError的构造器中。即表达式部分的唯一作用是产生一个消息字符串。

###### 7.4.2 启用和禁用断言

默认情况下，断言是被禁用的，可以使用-enableassertions或-ea参数开启断言，也可以使用参数对部分类或包开启断言-ea:myClass或-ea:com.hyy.app。同样的可以使用-disableassertions或-da参数禁用断言。需要注意的是，断言是类加载器的功能，开启或禁用断言后，无需重新编译程序，因此启用和禁用断言的参数也无法应用到没有类加载器的系统类中，对于这些类来说，需要使用-enablesystemassertions或-esa参数开启断言。

###### 7.4.3 使用断言完成参数检查

在java语言中，给出了三种处理系统错误的机制：

* 抛出异常
* 日志
* 使用断言

应该在以下情况下使用断言：

* 断言失败是致命的，不可恢复的错误。
* 断言只用于开发和测试阶段

###### 7.4.4 为文档假设使用断言

略

##### 7.5 记录日志

记录日志的好处：

* 可以很容易的取消日志记录或仅仅取消某个级别的日志，而且打开或关闭日志也很简单。
* 日志记录可以被记录定向到不同的处理器,输出到控制台或文件中。
* 日志记录器和处理器都可以对记录进行过滤。
* 日志记录可以使用不同的方式格式化，如纯文本或XML。
* 程序中可以使用多个日志记录器
* 可以使用配置文件控制日志配置，也可以在程序中进行配置

###### 7.5.1 基本日志

要使用简单的日志记录可以使用全局日志记录器，global logger,并调用info方法。代码如下：

```java
Logger.getGlobal().info("test log");
```

可以使用setLevel方法设置日志等级。如：

```java
Logger.getGlobal().setLevel(Level.OFF); //取消日志记录
```

###### 7.5.2 高级日志

一般的，尽量不要将所有的日志使用全局日志记录器记录，而是自定义日志记录器，如下：

```java
private static final Logger logger = Logger.getLogger("com.hyy.app");
```

与包名类似，日志记录器也有层次机构，只不过其层次性更强，如果对父记录器设置了记录级别，那么子记录器也将继承这些级别。日志记录通常具有以下级别：

* SEVERE
* WARNING
* INFO
* CONFIG
* FINE
* FINER
* FINEST

默认情况下只记录前三个级别，也可以使用setLevel()方法设置日志级别。ALL和OFF将开启或关闭所有的日志级别。可以使用warning(),info()方法记录某个级别的日志，也可以使用log()方法记录某个级别的日志，如下：

```java
logger.warning("warning msg");
logger.log(Level.INFO,"info msg");
```

默认的日志记录将包含调用的类名和方法名，但是如果虚拟机对执行过程进行了优化，那么将得不到这些信息，此时可以调用logp()方法获取这些信息。

```java
logger.logp(Level.INFO,"Main","main","detail msg");
```

###### 7.5.3 修改日志管理器配置

可以通过编辑配置文件修改日志系统的各种属性。默认情况下配置文件存在于jre/lib/logging.properties文件中，也可以在启动时使用`-Djava.util.logging.config.file=finePath` 命令指定配置文件的位置。日志管理器在VM启动时完成初始化，也可以在系统中调用System.setProperty()方法重新指定文件进行初始化。

###### 7.5.4 本地化

可以在应用程序中创建资源包，并在资源文件中指定要本地化的key，然后通过带资源文件的构造器指日志系统的资源文件，此时在打印日志时使用配置的key，日志中将显示本地化后的内容。也可以通过{0}{1}等占位符向本地化配置传值。

###### 7.5.5 处理器

默认情况下，日志将被发送到控制台处理器进行输出，也可以为日志管理器设置日志处理器，将其输出到FileHandler或SocketHandler中。我们也可以扩展Handler类或StreamHandler类实现自己的处理器。

###### 7.5.6 过滤器

日志管理器和处理器默认根据日志级别过滤日志，可以通过实现Filter接口自定义自己的过滤规则。

###### 7.5.7 格式化器

可以扩展Formartter类实现对日志消息的格式化，并调用日志处理器的setFormatter()方法设置格式化器。

###### 7.5.8 日志记录说明

* 为一个应用程序设置一个日志记录器，记录器的名字与包名相同。这是一个好的编程习惯。
* 最好在应用程序中设置默认配置
* 利用好日志记录级别

##### 7.6 调试技巧

* 使用日志或控制台输出一些值
* 每个类放一个单独的main方法，对每个类进行单元测试
* 使用单元测试框架如JUnit
* 日志代理
* 使用Throwable类的方法输出堆栈信息
* 使用-verbose参数启动虚拟机，可以看到类加载过程

#### 第八章 泛型程序设计

##### 8.1 为什么使用泛型？

泛型程序设计，意味着编写的代码可以被不同类型的对象所重用，如ArrayList类。下面分析泛型的好处

###### 8.1.1 泛型参数的好处

以ArrayList类为例，在有泛型之前，人们使用Object类型编写代码，这就意味着任何类型的对象都能存入集合中，此时在调用进行强制类型转换时可能会发生错误。使用泛型可以为集合指定一个泛型参数，此时只能向集合中添加泛型类型的对象。相当于把运行期的类型转换异常提前到了编译器检查。

###### 8.1.2 谁想成为泛型程序员

略

##### 8.2 定义简单的泛型类

一个泛型类是一个具有一个或多个泛型类型得类，代码如下：

```java
public class Pair<T> {
    private  T first;
}
```

也可以定义多个泛型参数，使用逗号隔开，一般的，Java中使用E代表集合的元素K,V代表键值对，T、U、S代表任意类型。

##### 8.3 泛型方法

在Java中还可以定义泛型方法，泛型类型放在修饰符和返回值中间。代码如下：

```java
public <T> T myMethod(T t){
    return t;
}
```

调用泛型方法时，需要在方法名之前指定泛型参数

```java
Arr arr = new Arr();
arr.<Integer>myMethod(123);
```

当编译器可以推断出泛型类型时，可以省略泛型参数：

```java
arr.myMethod(123);
```

##### 8.4 类型变量的限定

可以在<>中使用extends关键字限定泛型类型时某个类或接口的子类型，如果存在多个限定，则用&连接，在限定中可以存在多个接口，但是只能存在一个类，而且用类做限定时，只能放在第一位。

##### 8.5 泛型代码和虚拟机

###### 8.5.1 类型擦除

无论何时定义的泛型类型，都存在一个原始类型，原始类型就是擦除类型变量，并替换为限定类型(无限定类型用Object)。原始类型用限定的第一个参数，或Object替换。

###### 8.5.2 翻译泛型表达式

擦除泛型后，在调用方法时，将会返回原始类型，此时编译器会自动插入类型转换。

###### 8.5.3 翻译泛型方法

当泛型方法擦除后可能会产生与多态冲突的方法，此时编译器会生成一个桥方法，解决这个问题。

桥方法不仅可以用于泛型擦除，还可以在一个方法覆盖另一个方法时指定一个严格的类型，如覆盖clone方法。



总结：

* 虚拟机中没有泛型
* 类型参数用第一个限定类型或原始类型替换
* 编译器会生成桥方法保持多态
* 由于泛型擦除，编译器会在必要时插入类型转换

###### 8.5.4 调用遗留代码

指的是调用引入泛型之前的代码，略。

##### 8.6 约束与局限性

###### 8.6.1 不能用基本数据类型做为泛型参数

原因：泛型擦除后为Object类型，此类型不能存储基本数据类型，因此基本数据类型的泛型参数应当使用包装类。

###### 8.6.2 运行时类型检查只适用于原始类型

由于泛型擦除，进行类型比较时只能比较原始类型。getClass()方法也只能得到原始类型。如下：

```java
public static void main(String[] args) {
    Pair<String> p = new Pair<>();
    if (p instanceof Pair){

    }
    if (p instanceof Pair<String>){ //编译错误
        
    }
    String name = p.getClass().getName();
    System.out.println(name); //com.hyyngu.code_8.Pair
}
```

###### 8.6.3 不能创建参数化类型的数组

只是不允许使用new初始化泛型数组，但是可以声明变量，如下：

```java
Pair<String>[] p = new Pair<>()[10]; //编译错误
```

因为泛型擦除后的类型为Pair[]，可转换为Object[]，此时将可以向 p 中存储任意对象。（不建议声明这种数组）

###### 8.6.4 Varargs警告

对于可变参数列表的泛型方法，必须创建一个泛型数组，此时我们只会得到一个警告，而不是错误。可以使用两种方式压制这种警告：

* 使用@SuppressWarnings("unchecked")注解标注方法
* 使用@SafeVarargs注解标注方法

###### 8.6.5 不能实例化类型变量

不能使用new T()或T.class等语句创建对象或获取类型变量。Java8之后可以让调用者提供一个构造器表达式。代码如下：

```java
public static <T> Pair<T> makePair(Supplier<T> supplier){
    return new Pair<>(supplier.get(),supplier.get());
}

public static void main(String[] args) {
    Pair<String> pair = makePair(String::new);
}
```

Supplier<T>是一个函数式接口，用来返回无参数且类型为泛型的对象。

也可以使用反射机制实现以上效果，代码如下：

```java
public static <T> Pair<T> makePair2(Class<T> c){
    try {
        return new Pair<>(c.newInstance(),c.newInstance());
    }catch (Exception e){
        return null;
    }
}

public static void main(String[] args) {
    Pair<String> pair = makePair2(String.class);
}
```

###### 8.6.6 不能构造泛型数组

同样的在泛型中不能使用new关键字实例化泛型数组

###### 8.6.7 泛型类型在静态类型的变量中无效

由于静态变量和方法在类加载时就已经创建了，因此不能定义静态泛型变量，或使用了泛型变量的方法。

###### 8.6.8 不能捕获或抛出泛型类型的实例

不能使用泛型类扩展Throwable类，catch子句中也不能使用泛型变量。

###### 8.6.9 可以消除对受查异常的检查

可以使用泛型消除对受差异常的检查

```java
public static void thr(){
    try {
        FileInputStream fileInputStream = new FileInputStream("");
    }catch (FileNotFoundException e){
        Main.run(e);
    }
}

public static <T extends Throwable> void run(Throwable t) throws T{
    throw (T)t;
}
```

###### 8.6.10 注意擦除后的冲突

泛型擦除后的方法可能与其他方法产生冲突，如equals(T t)方法擦除后为equals(Object t)，与Object类中的方法冲突。解决的办法是重新命名。

##### 8.7 泛型类型的继承规则

无论泛型T和U具有怎样的关系，Pair<T>和Pair<U>没有任何关系。

```java
Pair<Child> childPair = new Pair<>();
Pair<Parent> parentPair = childPair; //编译错误
```

##### 8.8 通配符类型

###### 8.8.1 通配符概念

通配符类型中允许类型参数变化，通配符写法如下：

Pair<? extends Parent>表示泛型只能是Parent或其子类型。

###### 8.8.2 通配符的超类限定

与通配符限定和类型变量限定十分类似，超类限定是限定指定超类的语法。

Pair<？super Child>将指定只能是Child的超类。

区别，带有子类限定的通配符可以从泛型对象读取，而不可以写入，带有超类限定的通配符恰恰相反。

###### 8.8.3 无限定通配符

还可以使用无限定的通配符，如：Pair<?>

###### 8.8.4 捕获泛型通配符

编写一个交换元素的方法如下：

```java
public static void swap(Pair<?> p){
    ? buf = p.getFirst(); //Error
    p.setFirst(p.getSecond());
    p.setSecond(buf);
}
```

以上代码编译将不会通过，因为无法使用？来接收一个变量。此时可以使用一个辅助方法来捕获通配符：

```java
public static void swap(Pair<?> p){
    swapHelper(p);
}
public static <T> void swapHelper(Pair<T> p){
    T buf = p.getFirst();
    p.setFirst(p.getSecond());
    p.setSecond(buf);
}
```

##### 8.9 反射和泛型

###### 8.9.1 泛型Class对象

Class类是一个泛型类。这样在调用方法如newInstance()方法可以避免类型转换。

###### 8.9.2 使用Class<T>参数进行类型匹配

有如下代码：

```JAVA
public static <T> Pair<T> makePair2(Class<T> c){
    try {
        return new Pair<>(c.newInstance(),c.newInstance());
    }catch (Exception e){
        return null;
    }
}
```

此时编译器将可以推断出方法会返回一个Pair<T>类型的对象，从而进行类型检查。

###### 8.9.3 虚拟机中的泛型信息

虽然虚拟机对泛型类型进行了擦除，但是还保留了一些与泛型相关的信息，可以使用反射API获取这些信息。

#### 第九章 集合

##### 9.1 Java集合框架

###### 9.1.1 将集合的接口与实现分离

Java集合类库是将接口与实现相分离的，这样做的好处是可以使用接口类型存放引用(多态)，利用这种方式可以很容易的改变程序中使用的具体集合框架。Java集合类库中还有一组Abstract开头的类，这些类实现了集合的通用方法，如果想定义自己的集合，那么扩展它们比直接实现接口要容易得多。

###### 9.1.2 Collection接口

Collection接口是java集合框架的父接口，它继承了Iterable接口。

###### 9.1.3 迭代器

Iterator接口提供四个方法，用来遍历集合，经常使用的for each循环就使用了迭代器，如果想要使自己定义的集合类使用for each循环，那么必须实现Iterable接口来提供一个迭代器。

元素访问顺序取决于具体的集合，如ArrayList将从索引0到末尾，而HashSet的顺序是无法预知的。

Iterator接口的remove()方法将会移除上一次调用next()方法出现的元素。

###### 9.1.4 泛型实用方法

Collection接口和Iterator都是泛型接口，因此可以编写一些通用方法，如contains()方法。Java类库提供了一个AbstractCollection类，该类提供了集合的通用方法，此时扩展该类将会更容易实现自己的集合。

###### 9.1.5 集合框架中的接口

集合有两个基本接口Collection接口和Map接口。Collection接口有三个子接口List接口、Set接口、Queue接口。

##### 9.2 具体的集合

* ArrayList数组列表
* LinkedList链表列表       
* ArrayQueue循环数组队列
* HashSet无序集合
* TreeSet有序集合
* EnumSet枚举集合
* LinkedHashSet插入(或访问)有序的集合
* PriorityQueue优先级队列
* HashMap散列表
* TreeMap键有序散列表
* EnumMap枚举散列表
* LinkedHashMap插入(或访问)有序的散列表
* WeakHashMap集合内元素可以被垃圾回收的散列表
* IdentityHashMap使用==比较键值的散列表

###### 9.2.1 链表

在Java中所有的链表都是双向链表，Java中为有序集List提供了专门的迭代器ListIterator,该迭代器有add防范，可以为集合添加元素。在使用迭代器访问集合元素，如果该集合被其他迭代器，或集合本身的方法修改了结构时(add或remove)，迭代器会抛出异常。

###### 9.2.2 数组列表

List接口还有一个实现类，ArrayList这是一个数组列表，实现了RandomAccess接口(标记接口)支持通过索引快速访问元素访问。Vector也是一个数组链表，它是同步的，单线程环境下效率低下。

###### 9.2.3 散列集

有一种众所周知的数据结构可以快速访问对象，散列表，散列表为每个对象产生一个整型值作为散列码，通过散列码将元素放入数组的指定位置，若该位置已有元素，那么就发生了hash冲突，Java中解决hash冲突的方法时使用链表，当链表过长时，会进化成为红黑树。

Java集合框架提供了一个基于散列表的集，HashSet，遍历时，其元素是无序的。

###### 9.2.4 树集

TreeSet类是一个树集，其元素是有序的。由于树集内的元素都是有序的，因此使用TreeSet得元素必须实现了Comparable接口或为TreeSet提供一个Comparator比较器。

###### 9.2.5 队列与双端队列

JavaSE6开始Java提供了Deque接口，有ArrayDeque和LinkedList实现，这是一个双端队列，允许在队头和队尾添加删除元素。

###### 9.2.6 优先级队列

PriorityQueue是一个优先级队列，它使用了一种叫堆的数据结构，每次访问都会访问堆顶元素。同样的要使用优先级队列，必须实现了Comparable接口或提供一个Comparator比较器。

##### 9.3 映射

映射是一个键值对集合，可以通过键快速访问键对应的值（散列表）。

###### 9.3.1 基本映射操作

java中的基本映射有HashMap和TreeMap两种，TreeMap对键进行了排序，因此需要实现了Comparable接口的键或提供一个Comparator比较器。

* get(K key) 通过键获取值
* put(K key,V value)存入键值对
* remove(K key)移除键值对

还可以使用以下方式遍历映射：

```java
Map<String,String> map = new HashMap<>();
map.forEach((key,value)->{

});
```

###### 9.3.2 更新映射项

可以有以下几种方式更新映射项：

* 先get,再更新（当键为第一次出现时，可能出现空指针）
* 使用getOrDefault方法
* 使用merge方法

###### 9.3.3 映射视图

映射有三种视图：键集，值集合，键值对集。如下：

```java
Map<String,String> map = new HashMap<>();
Set<String> strings = map.keySet();
Collection<String> values = map.values();
Set<Map.Entry<String, String>> entries = map.entrySet();
```

如果通过键集删除元素，那么其对应的值也会删除，不能通过键集添加元素。

###### 9.3.4 弱散列映射

弱散列映射WeakHashMap使用弱引用保存键，对于这种引用，当垃圾回收机制发现对象只有弱引用时，将会把该对象放入弱引用队列中，也就是说，当对象不存在其他引用时，将会被放入队列中，WeakHashMap将会周期性的检查该队列，将无用的对象删除。

###### 9.3.5 链表散列集与映射

LinkedHashSet和LinkedHashMap会使用一个双向链表记住元素插入集合顺序（还可以基于访问顺序）

###### 9.3.6 枚举集与映射

EnumSet是一个枚举集的实现，由于枚举只有有限个实例，因此其内部使用位序列实现，如果枚举的值存在，则值为1否则为0；EnumSet类没有公共的构造器，只能通过静态工厂方法构造；如下：

```java
EnumSet<Size> all = EnumSet.allOf(Size.class);
EnumSet<Size> none = EnumSet.noneOf(Size.class);
EnumSet<Size> range = EnumSet.range(Size.SMALL,Size.MEDIUM);
EnumSet<Size> of = EnumSet.of(Size.SMALL,Size.MEDIUM);
```

EnumMap是一个键是枚举类型的映射，使用时需要键类型，如下：

```java
EnumMap<Size, User> enumMap = new EnumMap<>(Size.class);
```

###### 9.3.7 标识散列映射

IdentityHashMap是一个特殊的映射，其键的哈希计算方式并不调用hashCode()方法，而是调用System.identityHashCode()方法计算的，这是Object.hashCode()根据内存地址计算散列码的方式，因此这个散列表使用的是==而不是equals();

##### 9.4 视图与包装器

通过使用视图可以获得其他实现了Collection接口或Map接口的对象，通过视图可以对原集合进行操作。

###### 9.4.1 轻量级集合包装器

Arrays的静态方法asList将返回一个包装了普通Java数组的List包装器，如下：

```java
User[] user = new User[10];
List<User> users = Arrays.asList(user);
```

该方法返回的不是一个ArrayList对象，而是一个视图对象，可以使用get和set方法访问原始数组，而改变数组大小的方法（add或remove）将会抛异常。Java中的很多类如Arrays，Collections类提供了返回视图的方法，一定不要将视图和集合相混淆。

###### 9.4.2 子范围

可以调用集合的subList方法返回指定范围的元素视图，如下：

```java
List<User> users = new ArrayList<>();
List<User> userList = users.subList(10, 20); //左闭右开
```

可以将任何操作应用于子范围，如添加或删除，此时原始的列表也将发生变化。

###### 9.4.3 不可修改的视图

Collections类还提供了一些方法，用于返回不可修改的视图，如果试图通过视图修改集合，则会抛出异常。不可修改视图只是表示不能通过视图修改集合，可以通过集合本身修改。

###### 9.4.4 同步视图

如果有多个线程对集合进行访问时，就会出现很大的问题，此时不仅可以使用线程安全的集合类，还可以使用试图保证对集合的同步操作。如Collections类的synchronizedMap方法可以将任意映射转换为可以同步访问的Map。

###### 9.4.5 受查视图

受查试图是对于泛型检查的支持，有如下代码：

```java
ArrayList<String> strings = new ArrayList<>();
ArrayList rawList = strings;
rawList.add(new Date()); 
```

上述代码可以正常运行，但当调用以下方法时，将会抛出类型转换异常：

```java
String o = (String)rawList.get(0);
```

此时可以使用受查视图解决此类问题(代码将在add时就抛出异常)：

```java
ArrayList<String> strings = new ArrayList<>();
List<String> checkedList = Collections.checkedList(strings, String.class);
ArrayList rawList = checkedList;
rawList.add(new Date());
```

###### 9.4.6 关于可选操作的说明

略

##### 9.5 算法

###### 9.5.1 排序与混排

再Java类库中提供了许多算法，如Collections类的sort算法，这个算法将会对实现了List接口的集合进行排序，需要排序的元素必须实现了Comparable接口或提供一个比较器。如果需要逆序排序则可以调用reverseOrder()方法。

Java集合类库会将集合转换为数组，再对数组使用归并排序，最后将排序后的数组放入原集合。使用归并排序而不使用快速排序是因为归并排序时稳定的，而快速排序不是稳定的。

Collections类有一个方法shuffle，它可以随机的混排列表中的元素。

###### 9.5.2 二分查找

Collections类的binarySearch方法采用了二分查找法查找指定元素，但是集合必须是有序的，且集合中的对象必须实现了Comparable接口,或者为binarySearch方法提供一个比较器。

如果方法返回值大于0,则表示该元素在集合中的索引，如果返回负值，则表示集合中不存在该元素，但是可以通过这个负值将元素添加到指定的位置：该元素的正确位置为 index = -i - 1;如果为该方法传递一个链表，那么二分查找将会变为线性查找。

###### 9.5.3 简单算法

在Collections类中提供了一些简单且实用的方法，如查找集合中最大元素，二分查找，复制列表元素，对元素顺序进行倒序等。

###### 9.5.4 批操作

java有很多批量操作数据的方法，如a.removeAll(b)将移除集合a中出现的所有b集合中的元素，a,retainAll(b)将会删除a中没有出现在b中的元素。

###### 9.5.5 集合与数组的转换

如果要把一个数组转换为集合，可以调用Arrays类的asList方法(实际上是一个视图)，toArray方法则会把集合转换为数组。但是返回的数据类型为Object[];可以调用带参的toArray方法，传递一个数组。代码如下：

```java
ArrayList<String> strings = new ArrayList<>();
String[] objects = (String[]) strings.toArray(); //抛异常
String[] string = strings.toArray(new String[strings.size()]);
```

###### 9.5.6 编写自己的算法

在编写自己的方法时，利用泛型以及多态，尽量让方法可以被更多的集合类使用，而不是具体的一个集合类。

##### 9.6 遗留的集合

Java中遗留了许多集合框架之前的集合类，下面对其做介绍。

###### 9.6.1 HashTable类

HashMap类和HashMap类都是散列表，其区别，略。

###### 9.6.2 枚举

对于遗留集合可以使用Enumeration类进行遍历，其中的方法与迭代器中的方法十分类似。

###### 9.6.3 属性映射

属性映射是一个非常特殊的映射，其特殊性如下：

* 键和值都是字符串
* 可以保存在文件中，也可以从文件中加载
* 使用一个默认的辅助表

Java中实现这种映射的类时Properties类，其常用于系统的配置信息。

###### 9.6.4 栈

Java中还提供了栈这种数据结构，其由类Stack实现。

###### 9.6.5 位集

Java中的BitSet类是一个用于存放位序列的集合，如果需要高效的存取位序列(标志)，则使用BitSet比使用List<Boolean>高效得多。

#### 第十四章 并发

##### 14.1 什么是线程

###### 14.1.1 使用线程给其他任务提供机会

下面是利用线程执行一个任务的简单代码：

* 将任务代码放在实现了Runable接口的类的run方法中，这是一个函数式接口。
* 通过Runable接口创建一个线程
* 启动线程

还有一种方法是继承Thread类，并重写run方法，但是不推荐使用这种方式。因为为每个任务创建一个类的开销太大了，没有函数式接口方便。

启动线程时，调用Thread类的start()方法，而不是run方法。因为run方法不会启动一个线程，而是在当前线程中执行run方法，而start方法则会启动一个执行run方法的线程。

###### 14.2 中断线程

当线程执行完毕，或遇到了无法处理的异常时，线程将终止，在早期Java中提供了一个stop方法供其他线程调用终止线程。但是该方法已经被弃用了。

目前没有用于中断线程的方法，但是有一个interrupt方法可以申请终止线程,这个方法会将线程的中断标志位置为true,每个线程都应该不时地检查该标志位，以判断是否被中断。可以调用线程地isInterrupt方法判断当前线程是否被中断。当对阻塞地线程(sleep或wait)调用interrupt方法时，将会抛出异常。

有两个非常相似地方法静态方法interrupted和实例方法isInterrupted静态方法将检测当前线程是否被中断，如果中断则清除中断状态，而实例方法仅仅是检测是否中断。

##### 14.3 线程状态

线程有以下六种状态：

* 新建
* 可运行
* 被阻塞
* 等待
* 计时等待
* 被终止

###### 14.3.1 新创建线程

使用new操作符创建了一个线程，但是还没有开始运行，在其运行之前还有一些准备工作要做。

###### 14.3.2 可运行状态

一旦调用线程的start()方法,线程便处于可运行状态，它可能正在运行，也可能没有运行。这取决于操作系统为线程提供的运行时间。线程的调度细节取决于操作系统提供的服务。

###### 14.3.3 被阻塞线程和等待线程

当线程处于被阻塞状态或等待状态时，它暂时不活动，直到线程调度器重新激活它，细节取决于它是如何到达非活动状态的。

* 当一个线程试图获取对象的内部锁，而该锁被其他线程占用时，线程进入阻塞状态，当所有其他线程释放该锁，且线程调度器允许本线程持有锁的时候，线程将变成非阻塞状态。
* 当线程等待另一个线程通知调度器一个条件时，它自己进入等待状态，当调用Object.wait()、Thread.join()或等待Lock锁或者Condition条件时，线程会进入该状态。等待状态和阻塞状态有很大不同。
* 有几个方法可以让线程进入计时等待状态，这一状态将保持到时间结束或收到适当的通知。如Thread.sleep(),Object.wait()，Thread.join(),Lock.tryLock()和Condition.await()方法。

###### 14.3.4 被终止的线程

线程因如下原因进入终止状态：

* run()方法运行结束
* 遇到了没有捕获的异常，终止了run()方法的执行(已过时的stop()方法就是抛出ThreadDath错误对象杀死线程)

##### 14.4 线程属性

###### 14.4.1 线程优先级

在java中，每个线程都有优先级，默认情况下线程继承父线程的优先级可以调用setPriorty()方法设置线程优先级，优先级从1到10,默认为5；线程优先级不推荐使用，因为线程优先级依赖于操作系统，原因一：Java将线程的10个优先级映射到操作系统的优先级，不同的操作系统映射规则不同(如：在Oracle为Linux提供的Java虚拟机中优先级将被忽略，所有线程具有相同的优先级)。原因二：滥用优先级可能导致低优先级的线程长时间不能运行。

###### 14.4.2 守护线程

可以调用setDeamon()方法将线程设置为守护线程，守护线程唯一的用途就是为其他线程提供服务，当只剩下守护线程时，虚拟机就退出了。守护线程不应该访问资源，因为它可能在任何时候中断。

###### 14.4.3 未捕获异常处理器

可以为线程设置一个处理未捕获异常的处理器，该处理器是一个实现UnCaughtExceptionHandler接口的类。可以调用setUnCaughtExceptionHandler方法为当前线程设置处理器。也可以使用静态方法setUnCaughtExceptionHandler为所有线程设置处理器。如果不设置处理器，那么默认的处理器为空。如果不为独立的线程设置处理器，此时的处理器是ThreadGroup对象。

ThreadGroup类实现了UnCaughtExceptionHandler接口的方法，其做了如下操作：

* 如果该线程组有父线程组，调用父线程组的方法。
* 否则，如果Thread.getDefaultExceptionHandler 方法返回一个非空的处理器， 则调用该处理器。
* 否则，如果 Throwable 是 ThreadDeath 的一个实例， 什么都不做。
* 否则，线程的名字以及 Throwable 的栈轨迹被输出到 System.err 上。

##### 14.5 同步

###### 14.5.1 竞争条件的一个例子

以下给定一个银行转账的案例：

```java
public class Bank {

    private final double[] accounts;

    public Bank(int n,double initBalance){
        accounts = new double[n];
        Arrays.fill(accounts,initBalance);
    }

    public void unsafeTransfer(int from,int to,double amount){
        if (accounts[from] < amount)
            return;
        System.out.print(Thread.currentThread());
        accounts[from] -= amount;
        System.out.printf(" %10.2f from %d to %d ",amount,from,to);
        accounts[to] += amount;
        System.out.printf(" Total Balance:%10.2f%n ",unsafeGetTotalBalance());
    }

    public double unsafeGetTotalBalance(){
        double sum = 0;
        for (double a : accounts) {
            sum+=a;
        }
        return sum;
    }

    public int size(){
        return accounts.length;
    }

    public static final int NACCOUNTS = 100;
    public static final double INIT_BALANCE = 1000;
    public static final double MAX_AMOUNT = 1000;
    public static final int DELAY = 10;

    public static void main(String[] args) {
        Bank bank = new Bank(NACCOUNTS,INIT_BALANCE);
        for (int i = 0; i < NACCOUNTS; i++) {
            int fromAccount = i;
            Thread t = new Thread(()->{
                try {
                    while (true){
                        int toAccount = (int) (bank.size() * Math.random());
                        double amount = MAX_AMOUNT * Math.random();
                        bank. unsafeTransfer(fromAccount , toAccount , amount);
                        Thread.sleep((int) (DELAY * Math.random()));
                    }
                }catch (Exception e){

                }
            });
            t.start();
        }
    }

}
```

运行以上程序将发现，初始资金总额100000，开启多线程执行转账方法一段时间后，资金总额会有变化。

###### 14.5.2 竞争条件详解

代码：account[to] += amount;将执行以下指令：

* 将account[to]加载到寄存器
* 执行增加操作
* 将增加后的值写回account[to]

如果有两个线程同时执行该操作，线程一执行了前两步的时候，被剥夺了执行权，然后线程二将累加后的值写回account[to]，此时线程一恢复执行后进行的更新操作就是不正确的。

###### 14.5.3 锁对象

Java在JDK1.5引入了ReentrantLock类，它保护数据的代码如下：

```java
private ReentrantLock lock = new ReentrantLock();
lcok.lock();
try {

}catch (Exception e){

}finally {
    lcok.unlock();
}
```

一旦某个线程封锁了锁对象，其他线程将会进入等待状态。下面使用ReentrantLock对转账方法进行保护:

```java
public void reentrantLockTransfer(int from,int to,double amount){
    lock.lock();
    try {
        if (accounts[from] < amount)
            return;
        System.out.print(Thread.currentThread());
        accounts[from] -= amount;
        System.out.printf(" %10.2f from %d to %d ",amount,from,to);
        accounts[to] += amount;
        System.out.printf(" Total Balance:%10.2f%n ",unsafeGetTotalBalance());
    }catch (Exception e){
        
    }finally {
        lock.unlock();
    }
}

public double reentrantLockGetTotalBalance(){
    double sum = 0;
    lock.lock();
    try {
        for (double a : accounts) {
            sum+=a;
        }
        return sum;
    }catch (Exception e){

    }finally {
        lock.unlock();
    }
    return sum;
}
```

ReentrantLock锁是可重入锁，多次获取锁时，会使持有计数+1,释放一次锁会使值-1,当持有计数为0时，释放锁。

###### 14.5.4 条件对象

通常线程获取锁后，发现需要满足某些条件后才可以执行，此时需要使用一个条件对象管理那些获取锁但无法执行的线程，条件对象也被称为条件变量。如：在account[from] < amount时，不进行返回，而是等待其他线程向该账户注入资金，则可以使用一个条件变量改造程序。

```java
private Condition condition = lock.newCondition();

public void reentrantLockTransfer(int from,int to,double amount){
    lock.lock();
    try {
        while (accounts[from] < amount)
            condition.await();
        System.out.print(Thread.currentThread());
        accounts[from] -= amount;
        System.out.printf(" %10.2f from %d to %d ",amount,from,to);
        accounts[to] += amount;
        System.out.printf(" Total Balance:%10.2f%n ",unsafeGetTotalBalance());
        condition.signalAll();
    }catch (Exception e){

    }finally {
        lock.unlock();
    }
}
```

创建了一个条件表示余额充足，当发现余额不足时，线程调用await方法进入等待状态，并释放锁，等待其他账户注入资金后调用signalAll方法唤醒所有等待该条件的线程。唤醒后依然再while循环中再次进行测试。调用该方法只是唤醒等待的线程，它们仍然需要通过竞争去获取锁。

锁和条件对象关键：

* 锁可以保护代码片段，任何时刻只能有一个线程执行。
* 锁可以管理试图进入被保护代码的线程
* 锁可以有一个或多个条件对象
* 每个条件对象管理那些获得锁，但因其条件而不能运行的线程。

###### 14.5.5 synchronized关键字

在Java中，除了锁和条件变量外，还为每个对象提供了内部锁，如果方法使用synchronized关键字进行修饰，那么对象锁将保护该方法。内部对象锁只有一个条件对象，wait方法将线程添加到该条件的等待集中(等价于条件对象的await)，notify/notifyAll将唤醒该等待集中的线程(等价于signal和signalAll)。

可以使用synchronized关键字改造以上案例：

```java
public synchronized void synTransfer(int from,int to,double amount){
    try {
        if (accounts[from] < amount)
            wait();
        System.out.print(Thread.currentThread());
        accounts[from] -= amount;
        System.out.printf(" %10.2f from %d to %d ",amount,from,to);
        accounts[to] += amount;
        System.out.printf(" Total Balance:%10.2f%n ",synGetTotalBalance());
        notifyAll();
    }catch (Exception e){

    }
}

public synchronized double synGetTotalBalance(){
    double sum = 0;
    for (double a : accounts) {
        sum+=a;
    }
    return sum;
}
```

将静态方法使用该关键字修饰时，锁对象为该类的Class对象。使用对象内部锁代码非常简洁，但是也有以下局限：

* 不能中断正在试图获取锁的线程
* 不能设定获取锁的超时时间
* 每个锁只有单一的条件对象

###### 14.5.6 同步阻塞

有时还可以使用一个对象的锁，进入同步阻塞。如下：

```java
Object lock = new Object();
synchronized (lock){
    
}
```

使用一个对象来实现原子操作实际上被称为客户端锁定，但是要谨慎使用。

###### 14.5.7 监视器概念

监视器是面向对象的，可以在不考虑线程安全的情况下依然保证线程安全。监视器具有如特征：

* 监视器时只包含私有域的类
* 每个监视器类的对象都有一个相关的锁
* 使用该锁对所有的方法进行加锁
* 该锁可以有任意多个条件变量

然而Java对象不同于监视器：

* 域不必要求是私有
* 方法不必是synchronized的
* 内部锁对客户是可用的

###### 14.5.8 volatile域

volatile关键字为实例域的访问提供了一种免锁机制，但是，volatile并不具备原子性。

###### 14.5.9 final变量

还有一种情况可以安全的访问数据，就是当其被final修饰时。

###### 14.5.10 原子性

java.util.concurrent.atomic 包中有很多类使用了很高效的机器级指令(而不是使用锁)来保证其他操作的原子性。如 Atomiclnteger 类提供了方法 incrementAndGet和decrementAndGet, 它们分别以原子方式将一个整数自增或自减。

这些原子类有很多方法可以以原子的方式设置和增减值，但是如果要完成复杂的更新，则必须使用compareAndSet方法。如：

```java
public static AtomicLong aLong = new AtomicLong();
aLong.set(Math.max(aLong.get(),currMax));
```

当多线程执行上述操作时，将不能保证原子性，而使用compareAndSet方法则可以，如下:

```java
public static AtomicLong aLong = new AtomicLong();
long oldValue,newValue;
    do{
    oldValue = aLong.get();
    newValue = Math.max(oldValue,currMax);
}while (!aLong.compareAndSet(oldValue,newValue));
```

Java8之后甚至不需要编写以上代码而是直接使用一个lambda表达式：

```java
aLong.updateAndGet(x-> Math.max(x,currMax));
//或
aLong.accumulateAndGet(currMax,Math::max);
```

如果有多个线程更新原子值时，这些类的性能将会大大下降，此时可以使用LongAdder类或LongAccumulator类解决这个问题，LongAdder类包括多个变量，其总和为值，当多个线程更新时，可以操作不同的数。

LongAccumulator将这种思想推广到任意的累加操作。在构造器中，可以提供这个操作以及它的零元素。要加人新的值,可以调用 accumulate。

###### 14.5.11 死锁

如果所有的线程都进入等待可以让其执行的条件时，那么程序发生了死锁，如，所有线程因余额不足等待其他线程转入资金。导致程序死锁的原因还有很多，此处略。

###### 14.5.12 线程局部变量

可以使用ThreadLocal类为每个线程保存各自的实例，代码如下：

```java
public static final ThreadLocal<SimpleDateFormat> local = ThreadLocal.withInitial(SimpleDateFormat::new);
```

在线程调用get方法时，会触发initValue方法，为当前线程创建一个变量。

Random类是线程安全的，但是多线程下效率很低，可以使用ThreadLocalRandom.current() 返回属于当前线程的 Random 类实例。

###### 14.5.13 锁测试与超时

在线程获取锁时，如果获取失败，则会进入等待状态，因此在获取锁之前应该先进行锁测试，如下：

```java
if (lock.tryLock()){
    try {
        
    }finally {
        lock.unlock();
    }
}else {
    
}
```

tryLock方法可以尝试获取锁，获取成功后返回true，获取失败后返回false，然后可以执行其他操作。

还可以使用带超时参数的tryLock方法，如果使用带超时参数的方法，那么如果线程在等待中被中断则会抛出异常。在使用await方法等待条件时，也可以设置超时参数。

###### 14.5.14 读/写锁

java.util.concurrent.locks 包定义了两个锁类,ReentrantLock类和ReentrantReadWriteLock类(读写锁)。使用读写锁有以下几步：

* 构造ReentrantReadWriteLock实例
* 分离读写锁
* 用读锁对所有获取方法上锁
* 用写锁对所有修改操作上锁

读锁会共享读操作，排斥写操作，而写锁会排斥所有的读写操作。

###### 14.5.15 为什么弃用stop方法和suspend方法

stop方法会终止线程，导致线程释放持有的锁，当线程终止其他线程时，无法知道其是否处于安全状态，可能导致数据处于不安全的情况。

suspend方法会导致程序死锁，如：suspend挂起了某个持有锁的线程，其他线程等待锁，该线程等待被唤醒，程序将陷入死锁。

##### 14.6 阻塞队列

对于许多线程问题可以使用一个或多个队列以优雅的形式将其形式化，生产者线程向队列中插入数据，消费者线程从队列中取出它们。当试图向阻塞队列中添加元素，而队列已满，或试图从空队列中移出数据时，阻塞队列将导致队列阻塞。以下是阻塞队列的方法：

* add	添加一个元素，如果队列满抛出异常
* element 返回队列头元素，如果队列为空，那么抛出异常
* remove 移除并返回队列头部，若队列为空则抛出异常
* offer 添加一个元素，成功返回true,如果队列满返回false
* peek 返回队列头部元素，如果队列为空，则返回null
* poll 移除并返回队列头部元素，如果对列为空返回null
* put 添加一个元素，如果队列满则阻塞
* take 移除并返回头元素，如果对列空则阻塞

peek和poll方法返回null来提示失败，因此无法向阻塞对列中插入空值。

Java中提供了几种阻塞对列的变种：

* ArrayBlockingQueue ：一个由数组结构组成的有界阻塞队列。
* LinkedBlockingQueue ：一个由链表结构组成的无界(有界)阻塞队列。
* PriorityBlockingQueue ：一个支持优先级排序的无界阻塞队列。
* DelayQueue：一个使用优先级队列实现的无界阻塞队列。
* SynchronousQueue：一个不存储元素的阻塞队列。
* LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。
* LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。

##### 14.7 线程安全的集合

###### 14.7.1 高效的映射、有序集和队列

java提供了线程安全的映射、有序集、对列的高效实现。如：ConcurrentHashMap、ConcurrentSkipListMap、ConcurrentSkipListSet和ConcurrentLinkedQueue,这些集合使用复杂的算法，允许并发的访问数据结构的不同部分使竞争最小化。

与普通集合不同，并发集合的size方法是计算得出，而不是常数时间，jdk1.8后，还提供了mappingCount方法返回集合元素超过int范围的集合大小(返回long类型)。并发集合返回弱一致性迭代器，也就是说迭代器不一定反映出被构造之后的所有修改，它们不会将一个值返回两次，也不会抛出ConcurrentModificationException异常。

并发集合可高效的支持大量的读者，和一定量的写者，默认最大写者线程为16个。

###### 14.7.2 映射条目的原子更新

考虑以下一个案例，有多个线程统计单词出现的频率：

```java
private static ConcurrentHashMap<String,Long> map = new ConcurrentHashMap<>();

public static void add(String word) {
    Long oldValue = map.get(word);
    Long newValue = oldValue == null ? 1 : oldValue+1;
    map.put(word,newValue);
}
```

以上代码因为其操作序列不是原子性的，所以并不是线程安全的，传统的做法是使用replace()方法：

```java
private static ConcurrentHashMap<String,Long> map = new ConcurrentHashMap<>();

public static void add(String word) {
    Long oldValue,newValue;
    do {
        oldValue = map.get(word);
        newValue = oldValue == null ? 1 : oldValue+1;
    }while (!map.replace(word,oldValue,newValue));
}
```

线程将会以原子的方式不断尝试，直到更新成功。或者也可以使用原子类如：AtomicLong或LongAdder。更新操作为：

```java
private static ConcurrentHashMap<String, LongAdder> map = new ConcurrentHashMap<>();

public static void add(String word) {
    map.putIfAbsent(word,new LongAdder());
    map.get(word).increment();
    //由于putIfAbsent将返回映射的原值或者新设置的值，的所以有以下写法
    map.putIfAbsent(word,new LongAdder()).increment();
}
```

java8之后还提供了一些方便原子操作的方法，如：compute和merge，第一个方法提供一个键和计算新值的函数。

```java
private static ConcurrentHashMap<String, Long> map = new ConcurrentHashMap<>();

public static void add(String word) {
    map.compute(word,(k,v)-> v==null?1:v+1);
}
```

merge方法会在键不存在时提供一个初始值，否则调用函数计算新的值：

```java
private static ConcurrentHashMap<String, Long> map = new ConcurrentHashMap<>();

public static void add(String word) {
    map.merge(word,1L,(o,n)->o+n);
    //或
    map.merge(word,1L,Long::sum);
}
```

###### 14.7.3 对并发映射的批操作

java8为并发映射提供了批处理操作，批操作会遍历处理集合中的元素，但是批处理操作只能是映射状态的近似，因为有其他线程可能修改了集合。批操作有三种操作：

* search 搜索，为每个键或值提供一个函数，直到函数生成一个非null的结果，搜索终止，返回这个结果。
* reduce 归约，组合所有的键和值
* forEach 为所有的键和值提供一个函数

每个操作都有以下四个版本：

* operationKeys:处理键
* operatioriValues:处理值 
* operation:处理键和值 
* operatioriEntries:处理 Map.Entry 对象

对于以上操作需要提供一个阈值，当映射元素超过该值则并行完成批操作，否则将在一个线程中运行。

如找出以上案例中第一个出现次数超过1000次的单词：

```java
map.search(1,(k,v)->v>1000?k:null);
```

forEach方法有两种形式，第一种是为每个映射提供一个消费者函数，第二种形式是提供一个转换器和一个消费者，转换器的结果会发送到消费者。

```java
map.forEach(1,(k,v)-> System.out.println(k+"->"+v));
//或
map.forEach(1,(k,v)->k+"->"+v,System.out::println);
```

###### 14.7.4 并发集视图

Java中并没有提供并发的set集，但是使用ConcurrentMap的静态方法newKeySet会生成一个Set<Key>，这实际上是ConcurrentMap<Key,Boolean>的包装器，其值都为true。

```java
Set<String> words = ConcurrentHashMap.<String>newKeySet();
```

如果原来有一个映射，则可以使用keySet方法生成这个映射的键集，这个集是可变的，如果删除集中的某个元素，映射中的元素也会被删除，不能向集中添加元素(jdk1.8后可以为keySet方法提供一个默认值供插入使用)。

###### 14.7.5 写数组的拷贝

CopyOnWriteArrayList 和 CopyOnWriteArraySet 是线程安全的集合，其中所有的修改线程对底层数组进行复制。当构建集合迭代器后，如果数组被修改，而迭代器仍然引用着旧数组，因此访问它无需同步开销。

###### 14.7.6 并行数组算法

在 Java SE 8中， Arrays 类提供了大量并行化操作。静态 Arrays.parallelSort 方法可以对一个基本类型值或对象的数组排序。例如：

```java
String[] words = new String[10];
Arrays.parallelSort(words);
```

对对象进行排序时，需要提供比较器。

parallelSetAll 方法会用由一个函数计算得到的值填充一个数组。这个函数接收元素索引，然后计算相应位置上的值。最后还有一个 parallelPrefix 方法，它会用对应一个给定结合操作的前缀的累加结果替换各个数组元素。

```java
public static void main(String[] args) {
    int[] ints = new int[10];
    Arrays.parallelSetAll(ints,(i)->i+1);
    for (int i = 0; i < ints.length; i++) {
        System.out.println(ints[i]); // 1 2 3...10
    }
    Arrays.parallelPrefix(ints,(x,y)->x*y);
    for (int i = 0; i < ints.length; i++) {
        System.out.println(ints[i]); // 1 1*2 1*2*3...
    }
}
```

###### 14.7.7 较早的线程安全集合

java早期提供了Vector 和 Hashtable 类，分别是动态数组和散列表的线程安全实现，但是这些类被弃用了，取而代之的时ArrayList类和HashMap类,但是这些类不是线程安全的，但是任何集合类都可以通过同步包装器变成线程安全的，如：

```java
List<String> list = Collections.synchronizedList(new ArrayList<>());
```

最好使用线程安全的集合而不是包装器，但是有一个例外，就是经常被修改的数组列表，使用包装器的性能比CopyOnWriteArrayList高。

##### 14.8 Callable和Future

Runnable 封装一个异步运行的任务，可以把它想象成为一个没有参数和返回值的异步方法。Callable 与 Runnable 类似，但是有返回值。Callable 接口是一个参数化的类型， 只有一个方法 call。

Future 保存异步计算的结果。可以启动一个计算，将 Future 对象交给某个线程，然后忘掉它。Future 对象的所有者在结果计算好之后就可以获得它。Future 接口具有下面的方法：

* get() 获取结算结果，若计算未完成，则会阻塞,如果计算线程被中断则抛出异常
* get(long timeout,TimeUnit unit)带超时参数的获取方法，若计算未完成则抛出异常，计算线程被中断则抛出异常
* isDone()如果还在计算，则返回false,否则返回true
* isCancelled() 是否被取消
* cancel(boolean mayInterrupt)如果计算未开始，则取消计算，如果未开始且参数为true则中断线程。

FutureTask包装器是一种非常方便的方式，可将 Callable转换成 Future 和 Runnable, 它同时实现二者的接口。例如：

```java
public static void main(String[] args) throws Exception{
    Callable<String> call = ()->{
        return "123";
    };
    FutureTask<String> futureTask = new FutureTask<>(call);
    Thread t = new Thread(futureTask);
    t.start();
    System.out.println(futureTask.get());
}
```

##### 14.9 执行器

创建线程是有一定的代价的，如果在系统中创建了大量生命周期很短的线程，那么应该使用线程池，另一个使用线程池的原因是可以通过线程池限制并发的数目。Java中的执行器类Executor有很多静态方法来构建线程池：

* newCacheThreadPool 必要时创建新线程，空闲线程会保留60s
* newFixedThreadPool 该池有固定数目的线程，空闲线程会一直保留
* newSingleThreadExecutor 只有一个线程的池，顺序的执行每一个提交的任务
* newScheduledThreadPool 用于预定执行的固定线程池
* newSingleThreadScheduledExecutor 用于预定执行的单线程池

###### 14.9.1 线程池

newCacheThreadPool方法构建了一个线程池，对于每个任务，若线程池中有空闲线程可用，则取出一个线程，否则创建一个新线程。

newFixedThreadPool 方法构建了一个具有固定线程的线程池，如果提交的任务大于线程池的线程数量，那么多余的任务被放入队列中，等待其他线程空闲下来执行。

newSingleThreadExecutor 方法构建了单一线程的线程池，由一个线程依次执行所有的任务。

###### 14.9.2 预定执行

ScheduledExecutorService 接口具有为预定执行（ Scheduled Execution) 或 重 复 执 行 任务而设计的方法。它是一种允许使用线程池机制的 java.util.Timer 的泛化。Executors 类的newScheduledThreadPool 和 newSingleThreadScheduledExecutor 方法将返回实现了 ScheduledExecutorService 接口的对象。可以预定 Runnable 或 Callable 在初始的延迟之后只运行一次。也可以预定一个 Runnable对象周期性地运行。详细内容见 API 文档。

###### 14.9.3 控制任务组

有时使用执行器还有其他原因，如：控制一组相关的任务，可以调用shutdownNow方法取消所有的任务等。

###### 14.9.4 Fork-Join框架

Java se7引入了fork-join框架，它可以将任务分解为若干个子任务，然后将子任务的结果合并为最终结果。要采用这个框架完成计算，需要扩展RecursiveTask<T>类或RecursiveAction，前者用于有返回值的计算，而后者不返回任何结果，扩展这两个类后需要时间compute方法生成并调用子任务，最后合并其结果。

fork-join框架使用一种有效智能的方法来平衡可用线程的工作负载，这种方法被称为工作取密，每个工作线程都有一个双端队列来完成任务，一个工作队列将其子任务压入队头，当一个线程空闲时，它会从另一个线程对列尾部“密取”一个任务。forkjoin框架的简单使用如下：

```java
public class ForkJoinTest {

    public static void main(String[] args) {
        final int SIZE = 10000000;
        double[] numbers = new double[SIZE];
        for (int i = 0; i < SIZE; i++) {
            numbers[i] = Math.random();
        }
        Counter counter = new Counter(numbers,0,numbers.length,x->x>0.5);
        ForkJoinPool pool = new ForkJoinPool();
        pool.invoke(counter);
        System.out.println(counter.join());

    }



    static class Counter extends RecursiveTask<Integer>{
        public static final int THRESHOLD = 1000;
        private double[] values;
        private int from;
        private int to;
        private DoublePredicate filter;

        public Counter(double[] values, int from, int to, DoublePredicate filter) {
            this.values = values;
            this.from = from;
            this.to = to;
            this.filter = filter;
        }

        @Override
        protected Integer compute() {
            if (to - from < THRESHOLD){
                int count = 0;
                for (int i = from; i < to ; i++) {
                    if (filter.test(values[i]))
                        count++;
                }
                return count;
            }else {
                int mid = (from + to)/2;
                Counter first = new Counter(values,from,mid,filter);
                Counter second = new Counter(values,mid,to,filter);
                invokeAll(first,second);
                return first.join() + second.join();
            }
        }
    }

}
```

###### 14.9.5 可完成Future

处理非阻塞调用的传统方法是使用一个事件处理器，程序员要为任务结束之后的动作设置一个事件处理器，，如果下一个动作也是异步的，在它之后的动作也在一个不同的事件处理器中。这样的程序非常难以实现，而且不容易理解，Java8提供了一个CompletableFuture类，该类与事件处理器不同，可完成Future可以进行组合。例如以下代码：

```JAVA
public static CompletableFuture<String> readPage(URL url){
    return null;
}
public static CompletableFuture<List<URL>> getLinks(String page){
    return null;
}
public static void main(String[] args) throws Exception{
    URL url = new URL("");
    CompletableFuture<String> contents = readPage(url);
    CompletableFuture<CompletableFuture<List<URL>>> links = contents.thenApply(ComFuture::getLinks);
}
```

thenApply方法不会阻塞，而是会返回另一个Future,第一个Future完成时，其结果会提供给第二个方法。利用可完成Future可以设定按照什么样的顺序工作，而且所有的代码都在一起。

##### 14.10 同步器

Java类库提供了一些可以帮助人们管理互相合作的线程集的类，这些机制为线程之间具有共用集结点模式提供的预置功能，如果有线程集满足条件，应该直接使用它们而不是手动定义锁。

* CyclicBarrier 允许线程集等待其预定数目的线程到达一个公共障栅，然后选择一个线程执行樟栅中的动作。
* Phaser 类似于循环樟栅，不过有一个可变的计数
* CountDownLatch 允许线程集等待到计数器为0
* Exchanger 允许两个线程在准备好要交换的对象后交换对象
* Semaphore 允许线程集等待到被允许运行为止
* SynchronousQueue 允许一个线程将对象交给另一个线程

###### 14.10.1 信号量

信号量是被Dijkstra发明，用来作为同步原语使用的，它一般是一个计数器，用来限制进程（或线程）对某资源的访问数目的。

###### 14.10.2 倒计时门栓

CountDownLatch类可以让一个线程集等待直到计数器变为零为止，倒计时门栓是一次性的，一旦计数为零就不能重用了。举例来讲，假定一个线程集需要一些初始化工作，工作其线程被启动，但是在门外等待，直到做准备工作的线程准备好数据，然后调用countDown方法，这些线程就可以运行了。

###### 14.10.3 樟栅

CyclicBarrier类实现了一个集结点，称为樟栅，如：当大量线程完成某个计算的一部分，当所有线程计算完成时将结果组合在一起，使用樟栅时，可以让线程在完成计算后运行到樟栅出，一旦所有线程计算完毕，樟栅消失，线程可以继续运行。下面是其使用：

```java
//樟栅的使用,首先构造樟栅，并给出其线程数目，
CyclicBarrier barrier = new CyclicBarrier(10);
Thread[] threads = new Thread[10];
for (int i = 0; i < 10; i++) {
    threads[i] = new Thread(()->{
       //do work
        try {
            //在樟栅上调用await方法，也可以使用超时参数的方法
            barrier.await();
        }catch (Exception e){

        }

    });
}
```

如果在樟栅上的线程离开了樟栅(超时结束，或被中断)其他线程调用await将会抛出异常，而那些已经调用的线程将终止await的调用。也可以为樟栅提供一个默认的动作，当所有线程到达樟栅的时候就会执行该动作，如下：

```java
Runnable action = ()->{
    System.out.println(Thread.currentThread().getName());
};
CyclicBarrier barrier = new CyclicBarrier(10,action);
```

樟栅被称为循环的，是因为它可以在所有线程释放后被重用，而countDownLatch是一次性的。

Phaser类增加了更大的灵活性，它允许改变不同阶段的线程数目。

###### 14.10.4 交换器

当两个线程在同一个数据的两份实例上工作时，可以使用交换器Exchanger,典型的应用是，一个线程向其中放入数据，另一个线程消耗数据，当他们都完成后，相互交换缓冲区。

###### 14.10.5 同步队列

同步队列是一种将生产者与消费者配对的机制，当一个线程调用SynchronousQueue的put方法后，将被阻塞直到另一个线程调用take方法为止，与Exchanger不同，它的数据是单向的即，从生产者到消费者，而且它其实不是队列，因为其中没有任何元素。