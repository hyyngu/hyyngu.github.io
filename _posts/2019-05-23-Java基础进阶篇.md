#### 第一章 JavaSE 8的流库

##### 1.1 从迭代到流的操作

在处理集合时，我们通常会迭代遍历它的元素，并在所有元素上执行某些操作，如找出集合中长度大于3的单词数目。

```java
public static void main(String[] args) {
    List<String> words = new ArrayList<>();
    words.add("hello");
    words.add("java");
    words.add("se");
    int count = 0;
    for (String word : words) {
        if (word.length() >=3)
            count++;
    }
    System.out.println(count);
}
```

在使用流时，我们可以使用如下代码：

```java
count = words.stream().filter(word-> word.length() >= 3).count();
System.out.println(count);
```

流的版本不仅比迭代更简单，而且也更容易阅读，我们不必关心对集合做了哪些操作，只需通过方法名就可以知道代码意欲何为。如果将stream换为parallelStream就可以使用并行的方式执行计数。

```java
count = words.parallelStream().filter(word-> word.length() >= 3).count();
System.out.println(count);
```

流表面上看和集合非常相似，都可以让我们转换和获取数据，但是他们之间存在这显著差异。

* 流并不存储元素，这些元素存储在底层的集合中。
* 流的操作不会改变数据源。
* 流的操作时惰性执行的，直到它需要结果时才会执行。

流的典型流程：

* 创建一个流
* 指定操作将原始流转换为其它中间流
* 应用终止操作，产生结果。

##### 1.2 流的创建

Collection接口的Stream可以将任何集合转换为一个流，如果有一个数组那么可以使用Stream.of方法创建一个流。

```java
Stream<String> stream;
stream = Stream.of(new String[]{"hello", "stream"});
stream = Stream.of("hello", "stream");
```

使用Array.stream(array,from,to)方法，可以从array数组的from到to位置创建一个流(左闭右开)。

```java
stream = Arrays.stream(new String[]{"hello", "stream","i","am","hyy"},1,3);
```

使用Stream.empty()方法可以创建一个空的流。

```java
stream = Stream.empty();
```

Stream接口还有两个用于产生无限流的方法，generate方法会接受一个Supplier<T>的对象，如可以获得一个获取随机数的流。

```java
Stream<Double> randoms = Stream.generate(Math::random);
```

为了产生无限序列，可以使用iterate方法，它会接收一个种子值(初始值)，以及一个函数(从技术上讲是一个UnaryOperation<T>)，他会反复的将该函数应用到之前的结果上。

```java
Stream<BigInteger> integers = Stream.iterate(BigInteger.ZERO,i-> i.add(BigInteger.ONE));
```

Java中有大量方法都可以产生流，如Pattern类中有一个splitAsStream方法，它会将字符串按指定正则表达式，分割为一个个的单词组成流。

```java
String content = "i am a worker";
stream = Pattern.compile("\\s").splitAsStream(content);
```

File类的line方法会返回一个包含文件所有行的Stream。

```java
stream = Files.lines("filePath");
```

##### 1.3 fliter、map和flatMap方法

流的转换会产生一个新的流，它的元素派生于另一个流的元素，如使用filter可以产生一个匹配某种条件的流。

通常，我们需要按照某种操作来转换流中的值，此时可以使用map方法，并传递执行该转换的函数。

```java
stream = words.stream().map(String::toUpperCase);
```

使用map方法会有一个函数应用到每个元素上，并且其结果是包含所有应用了该函数结果的流。

如果我们有一个返回流的方法：

```java
public static Stream<String> letters(String s){
    List<String> result = new ArrayList<>();
    for (int i = 0; i < s.length(); i++)
        result.add(s.substring(i,i+1));
    return result.stream();
}
```

如果此时在一个字符流的map方法上应用该操作。

```java
ArrayList<String> strings = new ArrayList<>();
strings.add("hello");
strings.add("java");
strings.add("se");
Stream<Stream<String>> streamStream = strings.stream().map(OPO::letters);
```

此时将会得到一个包含流的流，其形式如下：[[h,e,l,lo],[j,a,v,a],[s,e]]，可以使用flatMap方法将其平摊为字母流[h,e,l,l,o,j,a,v,a,s,e]。

```java
Stream<String> s = strings.stream().flatMap(OPO::letters);
```

##### 1.4 抽取子流和连接流

调用Stream.limit(n)方法会返回一个新的流，它在n个元素之后结束(如果原来的流更短，那么他就会在流结束时结束)，这个方法对于结束无限流特别有用。

```java
//产生100个随机数的流
Stream<Double> randoms = Stream.generate(Math::random).limit(100);
```

调用Stream.skip(n)方法则恰恰相反，他会丢弃前n个元素。

```java
Stream<String> skip = words.stream().skip(2);
```

也可以使用Stream的静态方法concat将两个流连接起来。

```java
Stream<String> limit = words.stream().limit(2);
Stream<String> skip = words.stream().skip(2);
stream = Stream.concat(limit,skip);
```

##### 1.5 其他的流转换

distinct()方法会返回一个去除重复元素的流。

```java
Stream<String> uniqueWords = Stream.of("java","java","se").distinct(); //java se
```

可以使用sorted方法对流进行排序，它有多种版本，如使用Comparable,或者提供Comparator比较器。如按照字符串的长度排序。

```java
words.stream().sorted(Comparator.comparing(String::length).reversed());
```

peek方法会产生另一个流，它的元素与原来的元素一致，但是在每次获取一个元素时，都会应用一个函数。这对于调试十分方便。

```java
Stream<Integer> peek = Stream.iterate(1, i -> i * 2).peek(System.out::println).limit(20);
peek.count();
```

##### 1.6 简单约简

在本节中讨论的所有方法被称为简约，即终止操作，count方法就是一个简单约简：返回流中元素的数量。其他的简单约简还有min和max，他们会返回最大值和最小值。这些方法返回的是一个Optional<T>的值，它要么在其中包装了答案，要么表示没有任何值，因为流恰好为空。这样做的好处是避免因为返回null而产生空指针异常。

```
Optional<String> max = words.stream().max(Comparator.comparing(String::length));
System.out.println(max.orElse(""));
```

findFirst返回的是非空集合的第一个元素，它通常与filter操作搭配。

```java
//返回集合中第一个s开头的元素
Optional<String> first = words.stream().filter(s -> s.startsWith("s")).findFirst();
System.out.println(first.orElse(""));
```

如果不强调匹配第一个，而是任意符合条件的都可以，那么可以使用findAny方法，这在处理并行流时非常有用。

```java
Optional<String> any = words.parallelStream().filter(s -> s.startsWith("s")).findAny();
System.out.println(any.orElse(""));
```

如果只是想知道是否有元素匹配，那么可以使用anyMatch方法引入一个断言引元。而不必使用filter过滤，类似的方法还有allMatch和noneMatch,分别在全部匹配和没有匹配时返回true。

```
boolean anyMatch = words.parallelStream().anyMatch(s -> s.startsWith("s"));
boolean allMatch = words.parallelStream().allMatch(s -> s.startsWith("s"));
boolean noneMatch = words.parallelStream().noneMatch(s -> s.startsWith("s"));
```

##### 1.7 Optional类型

Optional<T>对象是一种包装器对象，它要么包装了类型为T的对象，要么没有包装任何对象。Optional<T>类型被当作一种更安全的类型用来代替T类型，T类型要么引用了一个对象，要么为null。但是这个类只有在正确使用的情况下才会安全。

###### 1.7.1 如何使用Optional值

有效的使用Optional值关键在于使用在值为null时可以产生代替值的方法，而在值存在的情况下才返回该值。

第一种有效的方法是当值不存在时，返回默认值来代替。

```java
//orElse 会在值不存在的情况下返回""空字符串
Optional<String> any = words.parallelStream().filter(s -> s.startsWith("s")).findAny();
System.out.println(first.orElse(""));
```

还可以在值不存在的情况下计算默认值。

```java
//值不存在时，调用方法计算默认值
String result = first.orElseGet(() -> Locale.getDefault().getDisplayName());
```

或者在没有任何值时，抛出异常。

```java
result = first.orElseThrow(IllegalArgumentException::new);
```

另一种策略是在该值存在时，才消费该值，ifPresent方法会接受一个函数，如果该值存在那么就会被传递给该函数，否则不会发生任何事情。

```java
//如，在值存在时将值插入集合中
first.ifPresent(v->words.add(v));
first.ifPresent(words::add);
```

当调用ifPresent方法时，不会从该函数获取到任何值。如果想要处理该函数的结果可以使用map方法。

```java
//add具有三种值，first存在值时，插入集合成功则为true,失败为false,first没有包装值，则为空的Optional类型
Optional<Boolean> add = first.map(words::add);
```

###### 1.7.2 不适合使用Optional值的方式

如果没有正确的使用Optional值，那么与之前的方式相比较，并没有太大差别。

```java
//并不比原始的方式更安全，value可能为null
String value = first.get();
value.getBytes();
```

虽然isPresent方法可以返回Optional是否有值，但是并不会比原始的方式更方便。

```java
//这种方式并不比下面原始的方式方便。
if ((value = first.get()) != null){
    value.getBytes();
}
if (value != null){
    value.getBytes();
}
```

###### 1.7.3 创建Optional值

之前讨论的Optional值都是系统中的方法返回给我们的，当我们需要创建自己的Optional值时，我们可以调用Optional.of()方法，或Optional.empty()方法。、

```java
Optional<Integer> integer = Optional.of(1);
//空的Optional
Optional<Object> empty = Optional.empty();
```

也可以使用ofNullable方法，它会在参数为null的情况下调用empty方法，不为null时调用of方法。

```java
Optional<Double> doubleOptional = Optional.ofNullable(1.0);
```

###### 1.7.4 使用flatMap方法构建Optional值的函数

假设有一个可以产生Optional<T>的方法f，类型T有一个可以产生Optional<U>的方法g，此时却不能使用s.f().g()得到Optioanal<U>类型的对象，因为f方法返回的是一个Optioanal<T>的对象，而不是T对象。此时可以使用flatMap方法。

```java
//如果s.f为null，则返回空的Optional,否则将值应用于方法g
Optional<U> u = s.f().flatMap(T::g);
```

##### 1.8 获取结果

当处理完流之后，通常需要查看其元素，此时可以调用iterator方法，它会返回一个迭代器，或者调用foreach方法，在并行流上foreach方法会以任意的顺序访问元素，若要使用元素的顺序，可以使用forEachOrdered方法，但是这样会丧失并行流的优势。也可以调用toArray方法获得一个数组，但是只能获取到Object类型的数组，如果想要得到原始数组，则可以调用带参数的方法。

```java
String[] strings = stream.toArray(String[]::new);
```

如果想要将流中的元素收集到另一个目标中，可以使用collect方法。它会接收一个Collector接口的实例，如将流中的结果放入列表或集中。

```java
List<String> list = stream.collect(Collectors.toList());
Set<String> set = stream.collect(Collectors.toSet());
```

假设要放入指定的集合中，则可以使用如下方法。

```java
TreeSet<String> treeSet = stream.collect(Collectors.toCollection(TreeSet::new));
```

如果想要链接流中的字符串，则可以调用Collectors.joining()方法。该方法也有参数的重载，用来以指定的分隔符将流中的字符串连接起来。

```java
String result = stream.collect(Collectors.joining());
```

如果想要将流的结果转换为总和，平均值，最大值和最小值，可以使用summarizingInt|Double|Long方法，这三个方法会返回一个Int|Double|LongSummaryStatistics的结果，同时计算其和、平均值、最大值最和小值。

```java
IntSummaryStatistics statistics = stream.collect(Collectors.summarizingInt(String::length));
statistics.getAverage();
statistics.getAverage();
```

##### 1.9 收集到映射表中

假设我们有一个Stream<Person>，并且想要收集到映射表中，此时可以使用Colletcors.toMap方法，该方法有两个引元，分别产生键和值。

```java
Stream<Person> personStream = personList.stream();
Map<Integer, String> map = personStream.collect(Collectors.toMap(Person::getId, Person::getName));
```

通常情况下，map里的值应该是具体的对象。因此第二个函数可以使用Function.identity()

```java
Map<Integer, Person> map = personStream.collect(Collectors.toMap(Person::getId, Function.identity()));
```

如果多个元素具有相同的键，那么收集器就会抛出异常，我们可以通过提供第三个引原来解决这种冲突.我们可以在该函数中返回原值、新值或组合他们。

```java
Map<Integer, Person> map = personStream.collect(Collectors.toMap(Person::getId, Function.identity(),(oldValue,newValue)->{return newValue;}));
```

我们也可以提供第四个引元来指定特定的实现类。

```java
TreeMap<Integer, Person> map = personStream.collect(Collectors.toMap(Person::getId, Function.identity(), (oldValue, newValue) -> {
    return newValue;
}, TreeMap::new));
```

##### 1.10 群组和分区

有时我们需要将指定键的所有值形成列表或集，此时可以使用分组函数groupingBy方法。

```java
Map<String, List<Person>> map = personStream.collect(Collectors.groupingBy(Person::getName));
```

当分组函数为断言函数即返回布尔值的函数时，流的元素被分为两个列表，返回true的元素和其他元素，这种情况下使用partitioningBy比使用groupingBy更加高效。

```java
Map<Boolean, List<Person>> map = personStream.collect(Collectors.partitioningBy(person -> "hyy".equals(person.getName())));
```

以上两节所讨论的转换为映射表的方法都有并发映射表的版本。

##### 1.11 下游收集器

groupingBy方法会产生一个映射表，它的每个值都是一个列表，如果想要以某种特定的方式处理这些列表，如使用集而不是列表，那么可以使用带第二个参数的groupingBy方法，这个参数会指定一个收集器。

```java
Map<String, Set<Person>> map = personStream.collect(Collectors.groupingBy(Person::getName,Collectors.toSet()));
```

java还提供了许多可以将分组信息约简为数字的收集器。

```java
Map<String, Long> count = personStream.collect(Collectors.groupingBy(Person::getName, Collectors.counting()));
Map<String, Long> sum = personStream.collect(Collectors.groupingBy(Person::getName, Collectors.summingLong(Person::getId)));
Map<String, Optional<Person>> max = personStream.collect(Collectors.groupingBy(Person::getName, Collectors.maxBy(Comparator.comparing(Person::getId))));
Map<String, Optional<Person>> min = personStream.collect(Collectors.groupingBy(Person::getName, Collectors.minBy(Comparator.comparing(Person::getId))));
```

mapping方法会将函数应用于下游收集器，并将其结果传递给另一个收集器。

```java
Map<String, Set<String>> map = personStream.collect(Collectors.groupingBy(Person::getName,Collectors.mapping(Person::getName,Collectors.toSet())));
```

##### 1.12 约简操作

reduce方法是一种从流中计算某些值的方法，最简单的方式是接受一个二元函数，他会从流中的前两个元素开始不断应用该函数。

```java
List<Integer> integers = new ArrayList<>();
integers.add(1);
integers.add(2);
integers.add(3);
// 1 + 2 + 3
Optional<Integer> sum = integers.stream().reduce(Integer::sum);
```

还有几种其他形式的reduce操作，如提供初始值，在流为空时返回初始值，而不是空的Optional。

```java
Integer sum = integers.stream().reduce(0, Integer::sum);
```

有时候流的类型和结果的类型不一致，如计算字符串流中所有长度的和。

```java
Optional<String> stringOptional = words.stream().reduce((word, length) -> length + word.length());
```

这种形式在并行处理时，会有多个这样的结果，因此需要提供第二个参数，将并行的结果合并。

```java
Integer length = words.stream().reduce(0, (total, word) -> total + word.length(), (total1, total2) -> total1 + total2);
```

##### 1.13 基本类型流

对于之前的整数流，我们都是把整数收集到Stream<Integer>中，对于基本数据类型来说，这种方式效率是底下的，java流库中有专门的基本数据类型的流。为了产生IntStream可以调用IntStream.of方法或者Arrays.stream方法。

```java
int[] ints = new int[]{1,2,3};
IntStream stream = IntStream.of(ints);
//ints数组从0到1构成基本类型流，左闭右开
stream = Arrays.stream(ints,0,1);
```

与对象流一致，我们可以使用generate和iterate方法生成无限流，IntStream和LongStream也可以使用range和rangeClosed方法指定范围生成步长为1的流。我们也可以调用对象流的mapToInt、mapToLong和mapToDouble方法通过对象流生成基本类型流。

```java
IntStream intStream = words.stream().mapToInt(String::length);
```

通常基本类型流和对象流有以下差异

* toArray方法返回基本类型数组
* 产生可选值结果的方法会返回OptionalInt、OptionalLong、OptionalDouble,这些类和Optional类相似，但是方法为getAsInt...等，而不是get。
* 具有返回总和、平均值、最大值、最小值的sum、average、max和min方法，而对象流没有。
* summaryStatistics方法会返回IntSummaryStatistics...等的对象，其中包含了和、平均值、最大值、最小值

Random类的ints,doubles和longs方法会返回由随机数构成的基本类型流。

##### 1.14 并行流

流使得并行处理块操作变得非常容易，但是首先要有一个并行流。Collection.parallelStream方法可以从任何的集合中获得并行流。

```java
Stream<String> parallelStream = words.parallelStream();
```

普通流的parallel方法也可以将任意的普通流转换为并行流。

```java
parallelStream = words.stream().parallel();
```

传递给并行流操作的函数不应被堵塞，因为并行流使用fork-join框架池来完成各个部分的计算。如果多个流被阻塞，那么池可能就无法做任何事情了。

排序并不排斥高效得并行处理，如当计算stream.map(fun)时，流可以被划分为n的部分，它们可以并行的处理，最后按照顺序组成结果。当放弃排序时，有些操作的效率会更高，如distanct方法，它会在重复时保留第一个元素，但是并行处理时，在所有结果完成之前，并不知道要丢弃哪些元素，此时可以使用unordered方法表明我们对排序不感兴趣。以下是使用该方法提高并行流limit的效率。

```java
//任意返回100个元素，不必是前100个
parallelStream.unordered().limit(100);
```

为了让并行流工作，必须满足大量的条件：

* 数据应该在内存中，否则将是低效的。
* 流应该可以被高效的分为若干部分，由数组或二叉平衡树支撑的流可以完成这一点，但是iterate方法返回的结果不太行。
* 流操作完成的工作量应该具有一定的规模，否则并行的意义不大。
* 流操作不应该被阻塞

#### 第二章 输入输出

本章节讨论的是Java中用于输入输出的各种接口

##### 2.1 输入/输出流

在Java API中，可以从其中读入一个字节序列的对象称为输入流，而可以向其中写入一个字节序列的对象称为输出流，这些字节序列的来源可以是文件、内存、或者是网络连接。抽象类InputStream和OutputStream构成了输入/输出类层次结构的基础。

因为面向字节的输入/输出流不便于处理Unicode形式存储的信息(因为每个unicode字符都用了多字节来存储)，因此从Reader和Writer类中继承出来了一个专门用于处理Unicode字符的单独的类层次结构，这些类的读取和输入都是两字节的，而不是基于byte。

###### 2.1.1 读写字节

InputStream类有一个抽象方法abstact int read();这个方法会读取一个字节，或者在遇到输入源结尾时返回-1。

在实现具体的输入流类时，必须重写该方法以提供功能，如再FileInputStream中这个方法从文件中读取一个字节。而System.in是从标准输入中读取信息，如控制台或重定向文件。

InputStream类还有若干个非抽象的方法，它们可以一次读取字节数组，或者跳过大量的字节，它们都调用了抽象的read方法，因此每个字类都只需要实现一个方法。

与此类似，OutPutStream类定义了抽象方法abstact voidwrite(int b);它可以向某个位置写一个字节。

read和write方法在执行时将阻塞，直至字节确实被读入或者写出，这就意味着，如果流不能被立即访问，那么线程将被阻塞，这使得这段时间内，其他线程线程将有机会执行有用的工作。

avaliable方法使我们可以检查当前可读入字节数量这意味着以下的代码不会被阻塞。

```java
int available = in.available();
if (available > 0){
    byte[] bytes = new byte[available];
    in.read(bytes);
}
```

当完成输入输出流的读写时，应该调用close方法来关闭它，这个调用会释放掉有限的系统资源，但是当打开的输入输出流很多且不释放时，那么系统资源将被耗尽。关闭输入输出流的同时缓冲区中的内容将会被送出，我们也可以手动调用flush方法送出缓冲区中的内容。

###### 2.1.2 完整的流家族

Java拥有极为庞大的流家族，按照使用方式来分，可以有字符流和字节流两种，InputStream和OutPutStream可以读写单个字节或字节数组，想要读写字符串或数字就需要更为强大的子类，如DataInputStream和DataOutputStream可以以二进制读写所有的基本Java类型。另一方面，Reader和Writer类的子类可以用来读写一个Unicode码元，其用法与字节输入输出流相似。

还有几个和流相关的接口，Closeable，Flushable，Readable和Appendable。前两个接口非常简单，分别有close方法和flush方法，Closeable接口还扩展了AutoCloseable接口，可以使用带资源的trycatch来关闭。

Input/OutputStream、Reader/Writer都实现了Closeable接口。OutputStream和Writer实现了Flushable接口。

###### 2.1.3 组合输入/输出流过滤器

FileInputStream和FileOutputStream只可以根据从磁盘上的文件中读取或写入字节，而DataInputStream和DataOutputStream只可以读入或写入数值类型，在Java中可以将他们进行组合。

```java
InputStream fileIn = new FileInputStream("");
InputStream dataIn = new DataInputStream(fileIn);
```

对于InputStream来说是没有缓冲区的，这样是低效的，如果想要使用缓冲区，那么必须使用以下的构造序列。

```java
InputStream dataIn = new DataInputStream(new BufferedInputStream(fileIn));
```

当读入输入时，经常需要预览下一个字节，以了解它是否是你想要的值，此时可以使用PushbackInputStream，

你可以预览值，并且在不符合期望时，将其退回流中。

```java
PushbackInputStream pushbackInputStream = new PushbackInputStream(fileIn);
int read = pushbackInputStream.read();
if (read != '<')
    pushbackInputStream.unread(read);
```

##### 2.2 文本输入与输出

在保存数据时，可以选择二进制数据或者文本数据，二进制格式I//O速度高效，但是不易阅读，而文本格式恰恰相反。在输入输出字符串时，需要考虑字符编码。Java内部使用的时UTF-16编码，而互联网上使用最多的是UTF-8。

InputStreamReader和OutputStreamWriter类将使用特定的编码方式，读取或写入数据。

```java
InputStreamReader reader = new InputStreamReader(fileIn, StandardCharsets.UTF_8);
OutputStreamWriter writer = new OutputStreamWriter(new FileOutputStream(""), StandardCharsets.UTF_8);
```

###### 2.2.1 如何写出文本输出

对于文本输出，可以使用PrintWriter,这个类拥有以文本格式输出字符串或数字的方法，它还有一个将PrinterWriter链接到FileWriter的简便方法。

```java
PrintWriter out = new PrintWriter("","utf-8");
//等同于
out = new PrintWriter(new FileOutputStream(""));
```

此时就可以使用和System.out一样的print,printf等方法打印数字，字符串，对象等数据。

如果写出器设置为自动冲刷的，那么调用printf等方法时，缓冲区中的内容被自动送出到具体的位置(打印写出器总是带有缓冲区的)，默认情况下自动重刷是关闭的。

print方法不抛出任何异常。我们可以调用checkError方法来查看输出流是否发生了错误。

###### 2.2.2 如何读入文本输入

最简单的读取输入的方式是使用卷1的Scanner类，或者可以将短小的文本文件读入字符串。

```java
Path path = null;
String s = new String(Files.readAllBytes(path));
```

或者获取文件的每一行到列表中去：

```java
List<String> strings = Files.readAllLines(path);
```

如果文件太大，也可以将其读入到Stream<String>流中。

```java
Stream<String> lines = Files.lines(path);
```

在早起的Java中，只有一个BufferReader类来处理文本输入，它的readLine方法会读入一行文本，在现在的Java版本中还有一个lines方法获取Stream<String>对象。与Scanner不同，它没有读取数字的方法。

###### 2.2.3 以文本格式存储对象

略

###### 2.2.4 字符编码方式

字节输入输出流一般操作的是字节，而更多时候我们希望操作的是字符，此时字符的编码就是一个很重要的问题。

Java针对字符使用的是Unicode编码，每个字符都有一个具有21位的整数，而不同的编码方式会将这21位按照不同的方式包装成字节。

最常见的方式是UTF-8,它会将每个字符的码点转换为1到4个字节的序列。

另一种常见的方式是UTF-16,它会将码点转换为1或2个16位值。

StandardCharsets类具有类型为CharSet的静态变量，用于表示虚拟机必须支持的编码方式。

可以使用forName方法获取某种编码的CharSet对象。

```java
Charset charset = Charset.forName("utf-8");
```

在读取或写入文件时，应该指定编码的CharSet对象，如下：

```java
String s = new String(Files.readAllBytes(path),StandardCharsets.UTF_8);
```

##### 2.3 读写二进制数据

对于文本格式来说，测试和调试显得十分方便，因为它是人类可阅读的，但是它并没有二进制传输高效。

###### 2.3.1 DataInput和DataOutput接口

DataOutput接口定义了一组用于以二进制格式写数组，字符、boolean值和字符串的方法，如writeChars,writeByte,writeUTF等。writeUTF使用修订版的8位Unicode转换格式写出字符串，并不是使用UTF-8编码，因此应该只在写出用于Java虚拟机的字符串时，才使用writeUTF方法，如编写生成字节码的程序。而在其他情况下应使用writeChars。

与之类似，DataInput接口中定义了读取二进制数据的相关方法。

###### 2.3.2 随机访问文件

RandomAccessFile类可以在文件的任何位置查找或写入数据，在打开文件时，可以通过字符串指定r或rw指定时只读，还是读写。

```java
RandomAccessFile file = new RandomAccessFile("","r");
file = new RandomAccessFile("","rw");
```

当你用RandomAccessFile打开文件后，该文件不会被删除，随机访问文件有一个表示下一个将被读入或写出的所处位置的指针，seek方法可以将该指针移动到文件的任何位置(从0到文件的字节长度之间)，getFilePointer方法将返回文件指针的当前位置。

###### 2.3.3 ZIP文档

ZIP文档通常以压缩格式存储了一个或多个文件，每个ZIP文档都有一个头，包含如每个文件名字，和压缩方法等信息，在Java中可以使用ZipInputStream来读入Zip文档，可以调用getNextEntry方法返回一个描述这些项的ZipEntry对象，调用ZipInputStream的getInputStream将该项传入，就可以得到该项的输入流。

要写出到Zip文件可以使用ZipOutputStream，而对于你希望放入到Zip文件中的每一项，都应该为其建立一个ZipEntry对象，并将文件名传递给构造器，他将设置文件日期和解压方法等参数，你也可以覆盖这些设置。然后嗲用ZipOutputStream的putNextEntry方法开始写出新文件，并在完成后调用closeEntry方法。

##### 2.4 对象输入/输出流与序列化

###### 2.4.1 保存和加载序列化对象

为了保存对象首先需要打开一个ObjectOutputStream,然后调用writeObject方法写出对象。为了将对象读回，需要使用ObjectInputStream实例调用readObject方法读入对象。但是读入和写出的对象都必须实现Serializable接口。

在使用ObjectOutputStream写出对象时，它会浏览对象的所有域，并存储他们的内容，但是当一个对象被多个对象共享时，只保存对象实例域的内容就不够了，保存这样的对象是一种挑战。因此Java中每个对象都是用一个序列号保存的，这就是序列化名称的由来：其算法如下：

* 对每个对象都关联一个序列号
* 如果该序列号第一次出现，保存对象到输入流中
* 如果某个对象已经保存过，那么只写出‘与序列号为x的对象相同’。

当读入对象时：

* 当读入的对象序列号是第一次出现时，用数据构建他。
* 当遇到与序列号x的对象相同标记时，获取这个序列号的引用

###### 2.4.2 理解对象序列化的文件格式

对象序列化是以特殊的格式存储对象数据的，对于其文件格式可以了解一下，也可以跳过。

每个文件都是以魔数开头的	AC ED

后面仅仅跟着对象序列化的版本 当前时 00 05

然后是它包含的对象序列，其顺序是它们存储的顺序。

字符串对象被表存为： 74 两字节表示的长度 所有字符   如 ：  74  00 05   Harry

当存储一个对象时，该对象所属的类也必须储存，这个类的描述包括：

* 类名
* 序列化的版本的唯一ID,它是数据域类型和方法签名的指纹
* 描述序列化方法的标志集
* 对数据域的描述

指纹是对类、超类、接口、域类型和方法签名按照规范方式排序，然后向安全散列算法SHA应用于这些数据获得的。SHA是一种可以为较大信息块提供指纹的快速算法，不论数据块多大，这种指纹总是20个字节的数据包，它是通过在数据上使用一种灵巧的位操作序列而创建的，本质上可以百分百保证数据发生变化时，其指纹也跟着变化。但是序列化机制只使用SHA的前八个字节作为类的指纹。

下面是类的标识符存储方式：

* 72 
* 2字节的类名长度
* 类名
* 8字节长的指纹
* 1字节长的标志
* 2字节长的数据域描述符的数量
* 数据域描述符
* 78 （结束标记）
* 超类类型 （没有则为70）

标志字节是Java.io.ObjectStreamConstants中定义的三位掩码构成的。我们要写出的类是实现了Serializable接口，其标志是02。

每个数据域的描述符格式如下：

* 1字节长的类型编码
* 2字节长的域名长度
* 域名
* 类名(如果域是对象)

当类型编码是L时，域名后边紧跟类名。类名和域名字符串不是以字符串编码74开头的，但域类型是。

如果在文件中再次需要相同的类描述符可以使用缩写版：

* 71		4字节长的序列号

对象被存储为：

* 73 		类描述符		对象数据

数组总是被存储成以下格式：

* 73 类描述符		4字节长的数组项数量		数组项

所有对象和类描述符在输出到文件时都被赋予了一个序列号，这个数字以00 7E 00 00开头，重复出现的对象和类描述符，都会引用第一次输出到文件的对象或类描述符。

空引用被存储为 

* 70 

总结：

* 对象输出流中包含所有对象的类型和数据域
* 每个对象都被赋予一个序列号
* 相同对象的重复出现将被存储为对这个对象序列号的引用

###### 2.4.3 修改默认的序列化机制

有时候某些数据域不适合被序列化，Java中有一个很简单的机制防止序列化，就是把数据域用transiert修饰,这些域在对象序列化时总是被跳过的。

序列化机制为单个类提供了一种方式，去将默认的读写方式添加验证或其他操作。可序列化的类可以添加如下方法：

```java
private void readObject(ObjectInputStream in) throws IOException,ClassNotFoundException;
private void writeObject(ObjectOutputStream out) throws IOException;
```

之后数据域就再也不会被序列化，取而代之的是调用这些方法。

除了让序列化机制来保存和恢复对象数据，类还可以定义它自己的机制。为了做到这一点，这个类必须实现Externalizable接口，并实现以下方法：

```java
@Override
public void writeExternal(ObjectOutput out) throws IOException {
    
}

@Override
public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {

}
```

这些方法对包括超类在内的整个对象的存储和读取负全责。

###### 2.4.4 序列化单例

在序列化和反序列话单例时可能出现一些安全问题，因为单例模式构造器是私有的，因此我们无法创建第二个对象，但是当其写入文件，在进行读取后，就会创建出第二个对象！(即使构造器是私有的，序列化机制也可以创建新的对象)。为了解决这个问题，需要定义一种readResolve的方法，该方法会在序列化之后调用，他必须返回一个对象，该返回值会成为readObject方法的返回值。

###### 2.4.5 版本管理

在程序进行迭代时，如果想要读取旧版本的类，首先需要获得旧版本类的指纹，使用参数serialver 类名，控制台就会打印出该类的指纹，为所有新版本的类添加常量serialVersionUID。如果一个类具有该静态成员，那么就不在计算指纹，而是使用该值。

###### 2.4.6 为克隆实现序列化

序列化还为克隆提供了一种简便的方式：直接将对象序列化到输出流中，然后将其读回。这是一种深拷贝。如果想要在clone方法中使用此方式，那么该类必须实现Cloneable接口和Serializable接口。尽管这样很方便，但是这样比创建新对象或者克隆数据域慢很多。

##### 2.5 操作文件

###### 2.5.1 Path

Path表示的是一个目录名序列，其后面还可以跟着一个文件名。以根目录开始的路径称为绝对路径，否则就是相对路径。例如：我们创建一个绝对路径和一个相对路径：

```java
Path absolute = Paths.get("/home","hyy");
Path relative = Paths.get("user","hyy","conf");
```

Paths的get方法接受一个或多个参数，将其用文件系统的分隔符分隔构成路径，如果结果不是文件系统合法的路径名，那么抛出异常。

组合或解析路径是常见的操作p.resolve(q),如果q为绝对路径，那么结果为q，否则根据文件系统规则p后跟着q。

resolve方法的对立面是relativize,即调用p.relativize(r)，将产生结果q，而对q解析的结果为r。

normalize方法将移除所有冗余的 . 和 .. 

toAbsolultePath方法将产生给定路径的绝对路径。

###### 2.5.2 读写文件

Files类使得读写文件变得更加容易，例如如下代码可以很容易的获取文件的所有内容。

```java
byte[] bytes = Files.readAllBytes(absolute);
```

如果想把文件当作字符串读入，可以在调用如下代码：

```java
String constant = new String(bytes,"utf-8");
```

如果希望将文件的每一个读取为一个集合，可以：

```java
List<String> lines = Files.readAllLines(absolute);
```

相反的，如果想要写出一个字符串到文件可以调用：

```java
Files.write(absolute,constant.getBytes("utf-8"));
```

也可以向指定文件追加内容：

```java
Files.write(absolute,constant.getBytes("utf-8"), StandardOpenOption.APPEND);
```

还可以将一个行的序列写入文件中：

```java
Files.write(absolute,lines);
```

这些方法虽然非常简便，但是只适用于处理较小的文件或数据，如果数据较大或是二进制数据那么应该使用输入输出流：

```java
OutputStream outputStream = Files.newOutputStream(absolute);
InputStream inputStream = Files.newInputStream(absolute);
Writer writer = Files.newBufferedWriter(absolute);
BufferedReader reader = Files.newBufferedReader(absolute);
```

###### 2.5.3 创建文件和目录

创建新目录可以调用：

```java
Files.createDirectory(absolute);
```

其中除了目录的最后一级，其他部分必须是已经存在的。想要创建多级目录可以使用：

```java
Files.createDirectories(absolute);
```

可以使用下面的语句创建一个空文件：

```java
Files.createFile(absolute);
```

如果文件已经存在了，那么就会抛出异常，因此检查文件是否存在和创建文件的操作必须是原子性的。

还有些方法可以在给定位置或系统指定位置创建临时文件或临时目录。

```
Files.createTempFile(absolute,prefix,suffix);
```

```java
Files.createTempFile(dir,prefix,suffix);
Files.createTempFile(prefix,suffix);
Files.createTempDirectory(dir,prefix);
Files.createTempDirectory(prefix);
```

其中dir是一个Path对象，prefix和suffix可以为null,如 prefix = null，suffix = .txt,会创建出一个像25345342.txt的路径。

###### 2.5.4 复制、移动和删除文件

将文件从一个位置复制到另一个位置可以直接调用：

```java
Files.copy(fromPath,toPath);
```

移动文件(即复制并移除文件)：

```java
Files.move(fromPath,toPath);
```

如果目标路径已经存在，那么复制或移动将会失败，如果想要覆盖已有的文件可以使用REPLACE_EXISTING选项，如果想要复制文件的属性，可以使用COPY_ATTRIBUTES选项，也可以同时指定以上两个属性。

```java
Files.move(fromPath,toPath, StandardCopyOption.REPLACE_EXISTING,StandardCopyOption.COPY_ATTRIBUTES);
```

可以将移动操作定义为原子性的，这样可以保证要么移动完成，要么文件处于原位置。

```java
Files.move(fromPath,toPath, StandardCopyOption.ATOMIC_MOVE);
```

还可以将输入流中的内容复制到Path中，或将Path中的内容复制到输出流中。

```java
Files.copy(inputStream,toPath);
Files.copy(fromPath,outputStream);
```

删除文件可以使用如下方法：

```java
Files.delete(path);
```

当删除的文件不存在时，会抛出异常，可以调用以下方法：

```java
Files.deleteIfExists(path);
```

该删除方法还可以用来删除空目录。

###### 2.5.5 获取文件属性

以下的静态方法将返回一个布尔值，表述检查路径上某个属性的结果。

* exists 是否存在
* isHidden 是否隐藏
* isReadable,isWritable,isExecutable
* isRegularFile,isDirectory,isSymbolicLink

size方法将返回文件的字节数。

```java
long size = Files.size(path);
```

getOwner方法将文件的拥有者作为UserPrincipal的一个实例返回。

所有的文件系统都有一个文件属性集，他们被封装在BasicFileAttributes接口中，这些属性与上述信息有部分重叠。基本文件属性包括：

* 创建文件、最后一次访问文件、修改文件的时间
* 文件是常规文件、目录还是符号链接或者这三个都不是
* 文件尺寸
* 文件主键，这是某种类的对象，具体类与文件系统有关，可能是文件唯一标识，也可能不是。

要获取这些属性可以调用：

```java
BasicFileAttributes basicFileAttributes = Files.readAttributes(path, BasicFileAttributes.class);
```

###### 2.5.6 访问目录中的项

静态的Files.list方法可以返回一个列出目录中所有项的Stream<Path>因为涉及到资源的关闭，所以最好使用带资源的try语句。

```java
try(Stream<Path> stream = Files.list(path)){
    
}
```

list方法不回进入子目录，如果想要遍历子目录可以使用walk方法。

```java
try(Stream<Path> stream = Files.walk(path)){

}
```

###### 2.5.7 使用目录流

Files.walk方法会产生一个可以遍历目录的Stream<Path>对象，有时候，需要对遍历进行更细粒度的控制，可以使用newDirectoryStream方法返回一个DirectoryStream对象，该方法是迭代器的一个子类，可以使用增强for循环。可以使用glob模式过滤文件。如：

```java
DirectoryStream<Path> paths = Files.newDirectoryStream(path，"*.java");
```

所有的glob模式如下：

* " * "		匹配路径组成部分中的任意多个字符		*.java 查找当前路径下的.java文件
* “ ** ”      匹配跨目录边界的任意多个字符              **.java 查找所有在子目录加的java文件。
* “ ？”        匹配一个字符      ？？.java 匹配文件名长度为2的Java文件
* " [...] "    匹配一个字符集合       Text[0-9].java   匹配所有Text0-Text9.java的文件
* "{... , ...}"   匹配由逗号隔开的多项之一              *.{java，class} 匹配所有的 java 和class文件
* " \ "       转义任意一个字符                

如果想要调用某个目录的所有子孙成员，可以转而调用walkFileTree方法。并向其传递一个FileVisitor类型的对象。这个对象会得到以下通知：

* FirstVisitResult visitFile(T path，BasicFileAttributes attr) 在遇到一个文件或目录时。
* FirstVisitResult preVisitDirectory(T dir,IOException ex) 在处理一个目录前
* FirstVisitResult postVisitDirectory(T dir,IOException ex) 在处理一个目录后
* FirstVisitResult visitFileFailed(T path,IOException ex) 打开文件失败时，如文件被占用。

对于上述每种情况可以指定是否执行下面的操作：

* FirstVisitResult.CONTINUE 继续访问下一个文件
* FirstVisitResult.SKIP_SUBTREE 继续访问，但是不在访问这个目录下的项了
* FirstVisitResult.SKIP_SIBLINGS 继续访问，跳过该目录的兄弟目录
* FirstVisitResult.TERMNATE 终止访问

###### 2.5.8 ZIP文件系统

Paths类会从默认的文件系统中查找路径，即用户本地的磁盘，你也可以使用其他的文件系统，最有用的时ZIP文件系统。以下的调用将会得到一个文件系统：

```java
FileSystem fs = FileSystems.newFileSystem(Paths.get("text.zip"),null);
```

如果知道文件名，那么从压缩文件中复制该文件：

```java
Files.copy(fs.getPath("fromPath"),toPath);
```

##### 2.6 内存映射文件

大多数操作系统都支持将文件的一部分映射到内存中，然后这个文件可以当作内存一样访问。这比访问磁盘快得多。

###### 2.6.1 内存映射文件的性能

Java.nio包使得文件映射变得非常简单，首先从文件中获得一个通道，通道是用于磁盘文件的一种抽象，它可以使我们访问内存映射、文件加锁机制以及文件间快速数据传递等操作系统特性。

```java
FileChannel channel = FileChannel.open(path,options);
```

然后调用通道的map方法获得一个ByteBuffer,你可以指定映射文件的区域和模式，支持的模式有三种：

* FileChannel.MapMode.READ_ONLY：所产生的缓冲区是只读的。任何写操作都会产生异常。
* FileChannel.MapMode.READ_WRITE: 所产生的缓冲区是可写的，任何修改都会在某个时刻写回文件，其他依赖该文件的程序不能立马看到修改。
* FileChannel.MapMode.PRIVATE:缓冲区是可写的，但是并不会应用到文件中。

一旦有了缓冲区就可以读写数据了，如可以进行遍历：

```java
while (buffer.hasRemaining()){
    byte b = buffer.get();
    //...
}
for (int i = 0; i < buffer.limit(); i++) {
    byte b = buffer.get(i);
    //...
}
```

###### 2.6.2 缓冲区数据结构

在使用内存映射文件时，我们在内存中创建了一个缓冲区，缓冲区Buffer类是一个抽象类，他有众多的实现，如ByteBuffer,CharBuffer,DoubleBuffer,IntBuffer等。每个缓冲区都具有：

* 一个容量，它永远无法被改变
* 一个读写位置，下一个值将在此进行读写
* 一个界限，超过此界限的读写是没有意义的。
* 一个可选标记，用于重复一个读取或写入操作

可以看出 0 <= 标记 <= 位置 <= 界限 <=容量

使用缓冲区的目的主要是进行“写，然后读取”循环：

* 初始缓冲区，界限等于容量
* 不断调用put写入数据，假设数据写完或写入原容量大小的数据
* 调用flip方法将界限设置到当前位置，并把位置复位到0
* 然后使用remaining方法检测是否有下一个值，不断使用get读取
* 最后调用clear方法清空缓冲区，并还原当前位置和界限

如果想要重读缓冲区，可以使用rewind方法或者mark/reset方法。

###### 2.6.3 文件加锁机制

有时候不同的程序可能会对同一个文件进行操作，和明显这些程序需要以某种方式通信，不然文件就会损坏，文件锁可以解决这个问题，它可以控制文件或文件中某个范围的访问权限。

要锁定一个文件时，可以调用FileChannel的lock或tryLock方法:

```java
channel.lock();
channel.tryLock();
```

也可以锁定文件的一部分：

```java
boolean share = false;
channel.lock(0,1000,share);
channel.tryLock(0,1000,share);
```

share为false表示锁定文件的目的是读写，而如果为true，则这是一个共享锁，它允许多个进程读取，并禁止任何进程获取独占锁，但是并非所有操作系统都支持共享锁，因此有时候获取到的仍然是独占锁，可以调用FileLock类的isShared方法查询持有的锁类型。

文件加锁是依赖于操作系统的，需要注意以下几点：

* 在某些应用中，加锁仅仅是建议性的，这些应用在未获得锁时，仍然可以向被另一个应用占用的文件执行写操作。
* 在某些操作系统中，加锁和内存映射是冲突的。
* 文件锁是由java虚拟机持有的，如果有两个应用程序由一个虚拟机启动，他们不可能都获得同一个文件的锁，当调用加锁方法时，如果虚拟机持有了该文件的锁，那么会抛出异常。
* 在一些操作系统中，关闭一个通道，会释放虚拟机持有的文件锁，因此应该避免在一个文件上打开多个通道。
* 在网络文件系统中锁定文件是高度依赖系统的，应尽量避免。

##### 2.7 正则表达式

正则表达式用于指定字符串的模式，你可以在任何需要匹配某种模式的字符串时使用正则表达式。正则表达式：

[Jj]ava.+表示：

* 字符串开头为 J 或 j
* 接下来三个字母是 ava
* 剩余部分为任意一个或多个字符

只需要了解一点正则表达式的语法就可以理解正则表达式的含义。

* 字符类 是一个括在括号里表示可选的字符集，如[JJ] [0-9] 等，“ - ”代表范围，^ 代表补集即除了指定字符之外。
* 如果字符类中包含 “ - ”那么必须为第一项或最后一项，如果要包含 [ 那么必须在第一项，如果包含 ^ 可以在除第一项和最后一项的任意位置。只需要转移 [ 和 \
* 有许多预定义的字符类 如 ： \d  

正则表达式语法：

* 大部分字符都与自身匹配
* . 符号可以匹配任意字符
* 使用 \ 作为转义字符，如\ .匹配句号 \ \匹配反斜杠
* ^ 和 $ 匹配某一行的开头和结尾
* 如果X和Y为正则表达式，那么XY表示任意X匹配后跟着Y匹配，X|Y表示任何X或Y的匹配。
* 可以将量词运用到表达式 X+ (1个或多个) X*(0个或多个) X？(0个或1个)
* 默认情况下，量词表达式会匹配最大可能的重复次数，可以使用后缀? 使得量词表达式匹配最小的重复次数。后缀+即使匹配失败也要匹配最大重复次数。
* 我们使用群组来定义子表达式，其中群组用()括起来。你可以询问模式匹配器每个组的匹配，或者使用\n引用某个组。从\1开始。

通常，我们只想找出，输入中一个或多个匹配的子字符串，此时可以使用Matcher类的find方法查找匹配内容，如果返回true可以使用start或end方法查找匹配内容，或使用不带引元的group方法来获取匹配的字符串。

Matcher类的replaceAll方法可以将正则表达式出现的所有地方，都用替换字符串来替换。replaceFirst替换模式匹配的第一个字串。如：把所有数字替换为#

```java
Pattern pat = Pattern.compile("[0-9]+");
Matcher mat = pat.matcher("123fh324");
mat.replaceAll("#");
```

最后Pattern类有一个，split方法，它可以用正则表达式来匹配边界，从而将输入分割成字符串数组。

#### 第三章 XML

##### 3.1 	XML概述

###### 3.1.1 XML文档的结构

XML文档以一个文档头开始，例如：

```java
<?xml version="1.0" encoding="utf-8"?>
```

严格来说，文档头是可选的，但是强烈推荐使用文档头。

文档头之后是文档类型的定义（DTD），文档类型定义是确保文档正确的一个重要机制，但是它不是必须的，例如：

//   <!DOCTYPE ...>

最后XML文档的正文必须包含根元素，根元素包含其他元素。

元素可以有子元素、文本或两者皆有。

元素和文本是XML文档主要支撑元素，可能还有以下标记：

* 字符引用的形式是&#十进制值，或&#x十六进制值。如：é 可以表示为 &#233 &#xE9。
* 实体引用的形式是&name;下面这些实体引用：&lt、&gt...表示大于，小于等字符。
* CDATA部分用<![CDATA[ 和 ]]> 来限定其界限，它们是字符数据地一种特殊形式，可以用来包含< > &等字符，而部将其解释为标记。
* 处理指令是指哪些专门在处理XML文档的应用程序中使用的指令，它们由<? 和 ?>。
* 注释：由 <!-- 和 -- > 包围的元素。

##### 3.2 解析XML文档

要处理xml文档，就先要解析它，解析器是这样的一个程序：它读入一个文件，确认这个文件具有正确的格式，然后将其分解成各种元素，Java提供了两种XML解析器。

* 像文档对象模型解析器(DOM)这样的树形解析器
* 像XML简单API解析器(SAX)这样的流机制解析器，它们在读入XML文档时，生成对应的事件

DOM解析器相对容易一些，如果要处理很长的文档，那么生成树结构会消耗大量的内存，或者如果仅仅对某些元素感兴趣，而不关心它的上下文，那么应该使用流解析器。

要读入XML文档首先需要一个DocumentBulider对象，可以从DocumentBuliderFactory中得到这个对象。

```java
DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();
DocumentBuilder builder = factory.newDocumentBuilder();
```

现在可以从文件或url或输入流中读取某个文档。

```java
File file = new File("");
String url = "";
InputStream input = new FileInputStream("");
builder.parse(file);
builder.parse(url);
builder.parse(input);
```

调用getDocumentElement方法用来启动对文档内容的解析，首先会返回根元素，getTagName方法可以返回元素的标签名。如果要得到元素的子元素，可以调用getChlidNodes方法。该方法返回一个NodeList的集合。在解析元素时，如果标签只含有文本内容，这些文本内容将被Text类型的子节点中，可以直接调用getFirstChild方法而不必再遍历一遍集合。然后调用getData方法获取存储在Text节点中的字符串。

如果要获得节点的属性，可以调用getAttributes方法。他返回一个NamedNodeMap对象，可以遍历这个对象得到节点的所有属性。然后调用getNodeName和getNodeValue方法得到属性名和属性值。或者如果知道属性名，可以调用带参数的getAttribute方法直接获取属性值。

##### 3.3 验证XML文档

如果要指定文档结构，可以提供一个文档类型定义（DTD）或一个XML Schema定义。

###### 3.3.1 文档类型定义

提供DTD的方式有多种，可以像下面一样将其纳入到XML中。

```java
<！DOCTYPE configuration [<!ELEMENT ...>...]>
```

一般很少把DTD定义在内部，而是会指定一个包含DTD的URL。如:

```java
<！DOCTYPE configuration SYSTEM "conf.dtd">
<！DOCTYPE configuration SYSTEM "https：//.../conf.dtd">
```

ELEMENT规则用于指定某个元素可以拥有怎么样的子元素，可以指定一个正则表达式。

* E* 0个或多个 E
* E+ 1个或多个E
* E? 0个或1个E
* E1|E2...En  E1、E2、...En中的一个
* E1,E2,E3...  E1后跟着E2,E3...
* #PCDATA  文本
* (#PCDATA|E1|E2...) 0或多个文本且E1.E2...以任意顺序排列
* ANY 可以有任意元素
* EMPTY 不允许有任何元素

还可以指定合法元素的属性规则：

```java
<!ATTLIST ...>
```

* CDATA 任意字符串
* （A1|A2...）字符串 A1、A2...之一
* NMTOKEN NMTOKENS 1或多个名字标记
* ID 一个唯一的id
* IDREF IDREFS 1或多个对唯一ID的引用
* ENTITY ENTITYS 1或多个未解析的实体

属性的默认值：

* #REQUIRED 属性值是必须的
* #IMPLIED    属性是可选的
* A 属性是可选的，若未指定则为A
* #FIXED A,属性值必须未指定或为A，解析器都将解析为A

我们可以调用工厂的setValidating方法打开验证DTD特性。当解析器发生错误时，如果希望执行某些操作，可以指定错误处理器。我们可以通过DocumentBulider类的setErrorHandler方法来安装错误处理器。需要为该方法提供一个实现了ErrorHandler接口的对象。

###### 3.3.2 XML Schema

Schema的语法比DTD复杂许多，它为每个元素都定义了类型，类型可以是简单类型或者是复杂类型。一些简单的类型已经被建立到了Schema内，包括：

* xsd:string
* xsd:int
* xsd:boolean

我们可以定义自己的简单类型，如定义一个枚举类型：

```java
<xsd:simpleType name="StyleType" xmlns:xsd="http://www.w3.org/2001/XMLSchema">
    <xsd:restriction base="xsd:string">
        <xsd:enumeration value="PLAIN" />
        <xsd:enumeration value="BOLD" />
    </xsd:rerestriction>
</xsd:simpleType>
```

xsd:sequence结构和DTD中的连接符号等价，而xsd:choice结构和|操作符等价。

如果要允许重复元素，可以指定minoccurs和maxoccurs属性。

```java
<xsd:elenment name="item" minoccurs = "0" maxoccurs = "unbounded" />
```

如果要指定属性，可以定义xsd:attribute元素。

解析带有Schema的XML和DTD文件，十分相似。但是有三点不同：

* 必须打开对命名空间的支持  factory.setNamespaceAware(true);
* 必须通过以下的魔咒来处理Schame的工厂

```java
final String JAXP_LANGUAGE = "http://java.sun.com/xml......";
final String W3C_XML_SCHEMA = "http://www.w3.org/2001/XMLSchema";
factory.setAttribute(JAXP_LANGUAGE,W3C_XML_SCHEMA);
```

* 解析器不会丢弃元素中的空白字符。

##### 3.4 使用XPath定位信息

如果有以下的XML文档：        

```java
<configuration>
    ...
    <database>
        ...
        <username>...</username>
        ...
    </database>
    ...
</configuration>
```

可以通过XPath表达式/configuration/database/username的到该属性的值。

使用XPath表达式执行以下操作，比使用DOM的方式要简单许多。

* 获得文档节点
* 枚举它的子元素
* 定位database元素
* 定位其子节点名字为username的节点
* 定位其子节点中的text节点
* 获取其数据

XPath可以描述一个节点集，如/configuration/row描述了所有的row元素。可以使用[]获取特定的元素/configuration/row[1]获取第一个row元素(索引从1开始)，使用@符号可以获取属性值，/configuration/row[1]/@auchor，获取第一个row的auchor属性。

Java中有一个API可以用来计算XPath表达式。首先需要从一个XPathFactory创建一个XPath对象：

```java
XPathFactory xPathFactory = XPathFactory.newInstance();
XPath path = xPathFactory.newXPath();
```

然后调用evluate方法计算XPath表达式。

```java
String username = path.evaluate("/configuration/database/username", doc);
```

该方法适合用来读取文本，但是如果读取的是一个节点集，则需要如下调用：

```java
NodeList nodeList =  (NodeList)path.evaluate("/configuration/database/username",doc,XPathConstants.NODESET);
```

如果是单个节点：

```java
Node node = (Node)path.evaluate("/configuration/database/username", doc,XPathConstants.NODE);
```

如果是一个数字：

```java
int count = ((Number)path.evaluate("/configuration/database/username", doc,XPathConstants.NUMBER)).intValue();
```

##### 3.5 使用命名空间

Java程序使用包名来解决冲突，XML也有类似的命名空间机制，可以用于元素名和属性名。

你可以控制解析器对命名空间的解析，要打开命名空间特性，可以调用setNameSpaceAware方法。

```java
factory.setNamespaceAware(true);
```

这样，该工厂产生的生成器都支持命名空间了。每个节点有三个属性：

* 带有前缀的限定名，由getNodeName和getTagName方法返回
* 命名空间URI,由getNameSpaceURI方法返回
* 不带前缀和命名空间的本地名，由getLocalName方法返回

##### 3.6 流机制解析器

Java提供了两种流机制解析器：SAX解析器和StAX解析器。SAX使用的是事件回调，而StAX解析器提供了遍历解析事件的迭代器，使用起来更加方便一些。

###### 3.6.1 使用SAX解析器

SAX解析器在解析XML输入数据的各个部分时会报告事件，但不会存储文档，在使用解析器时，需要一个处理器来为各种解析器时间定义动作。ContentHandler接口定义了若干个在解析文档时调用的回调方法。下面是重要的几个：

* startElement和endElement 在遇到起始或终止标签时调用
* characters在每当遇到字符数据时调用
* startDocument和endDocument分别在文档开始和结束时各调用一次

与DOM解析器一样，需要调用工厂类的setNamespaceAware方法来激活命名空间处理特性。

###### 3.6.2 使用StAX解析器

StAX解析器是一种拉解析器，与安装时间解析器不同，他只需使用循环迭代处理所有的事件。

##### 3.7 生成XML文档

###### 3.7.1 不带命名空间的文档

要建立一个DOM树，可以从一个空文档开始，通过DocumentBuilder类的newDocument方法创建一个空文档。

```java
DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();
DocumentBuilder builder = builderFactory.newDocumentBuilder();
Document document = builder.newDocument();
```

